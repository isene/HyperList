#!/usr/bin/env ruby
# encoding: utf-8

# HyperList TUI - A terminal interface for HyperList files
# Based on hyperlist.vim by Geir Isene

# Check for help/version BEFORE loading any libraries
if ARGV[0] == '-h' || ARGV[0] == '--help'
  puts <<~HELP
    HyperList v1.5.1 - Terminal User Interface for HyperList files
    
    USAGE
      hyperlist [OPTIONS] [FILE]
      
    OPTIONS
      -h, --help     Show this help message
      -v, --version  Show version information
      
    ARGUMENTS
      FILE           Optional HyperList file to open (.hl extension)
                     If not provided, starts with a new empty HyperList
      
    EXAMPLES
      hyperlist                  Start with a new HyperList
      hyperlist todo.hl          Open todo.hl
      hyperlist ~/lists/work.hl  Open work.hl from home directory
      
    KEY COMMANDS
      ?              Show key bindings help
      ??             Show full HyperList documentation
      q              Quit (with save prompt if modified)
      :w             Save file
      :q             Quit
      :wq            Save and quit
      
    FEATURES
      • Full HyperList syntax support with color highlighting
      • Folding/expanding of hierarchical items
      • Search and navigation
      • Checkboxes with date tracking
      • Templates for common list structures
      • Macro recording and playback
      • Split view for working with multiple sections
      • Export to Markdown, HTML, plain text, and PNG graphs
      • Auto-save capability
      • Multi-level undo
      • Vim-style marks and jumping
      
    For more information and HyperList documentation, visit:
      https://github.com/isene/hyperlist
      
  HELP
  exit 0
elsif ARGV[0] == '-v' || ARGV[0] == '--version'
  puts "HyperList v1.5.1"
  exit 0
end

# Only load libraries if we're actually running the app
require 'io/console'
require 'date'
require 'rcurses'
require 'cgi'
require 'openssl'
require 'digest'
require 'base64'
require 'fileutils'
require 'json'

class HyperListApp
  include Rcurses
  include Rcurses::Input
  include Rcurses::Cursor
  
  VERSION = "1.6.0"
  
  def initialize(filename = nil)
    @filename = filename ? File.expand_path(filename) : nil
    @items = []
    @current = 0
    @offset = 0
    @modified = false
    @mode = :normal
    @message = ""
    @search = ""
    @search_matches = []  # Track search match positions
    @fold_level = 99
    @config_line = nil  # Store config line from file
    @theme = "normal"  # Default theme
    @wrap = false  # Line wrapping disabled by default
    @show_numbers = false  # Line numbers disabled by default
    @command_history = load_command_history  # Command history for : commands
    @clipboard = nil
    @undo_stack = []
    @undo_position = []  # Stack of cursor positions for undo
    @redo_stack = []
    @redo_position = []  # Stack of cursor positions for redo
    @last_action = nil  # Store the last editing action for '.' repeat
    @last_action_type = nil  # Type of last action
    @processed_cache = {}  # Cache for processed text
    @presentation_mode = false  # Presentation mode flag
    @last_key = nil  # Track last key for double-key combos
    @last_rendered_lines = []  # Track last rendered lines
    @recent_files_path = File.expand_path("~/.hyperlist_recent")
    @auto_save_enabled = false
    @auto_save_interval = 60  # seconds
    @last_auto_save = Time.now
    @templates_dir = File.expand_path("~/.hyperlist/templates")
    ensure_templates_dir
    @templates = load_templates
    @macro_recording = false
    @macro_register = {}  # Store macros by key
    @macro_buffer = []  # Current macro being recorded
    @macro_key = nil  # Key for current macro
    @encryption_key = nil  # Store derived encryption key
    @encrypted_lines = {}  # Track which lines are encrypted
    @st_underline_mode = 0  # 0: none, 1: underline states, 2: underline transitions
    @split_view = false
    @split_items = []  # Second view items
    @split_current = 0  # Second view cursor
    @split_offset = 0  # Second view scroll offset
    @active_pane = :main  # :main or :split
    @message_timeout = nil  # For timed message display
    
    # Global configuration
    @config_file = File.expand_path("~/.hyperlist/config.yml")
    @indent_size = 2  # Default indentation (2-5 spaces)
    load_config
    
    # Terminal setup
    if IO.console
      @rows, @cols = IO.console.winsize
    else
      @rows = ENV['LINES']&.to_i || 24
      @cols = ENV['COLUMNS']&.to_i || 80
    end
    
    # Setup terminal resize handler
    setup_resize_handler
    
    # Setup UI first (to initialize @footer) before loading file
    setup_ui
    
    # Load file if provided (after UI is set up)
    if @filename && File.exist?(@filename)
      load_file(@filename)
    else
      # Start with empty list
      @items = [{"text" => "New HyperList", "level" => 0, "fold" => false}]
    end
  end
  
  def setup_ui
    # Only do rcurses operations if initialized
    if defined?(Rcurses.instance_variable_get) && Rcurses.instance_variable_get(:@initialized)
      Rcurses.clear_screen
      Cursor.hide
    end
    
    # Ensure we have the latest terminal size
    if IO.console
      @rows, @cols = IO.console.winsize
    else
      @rows = ENV['LINES']&.to_i || 24
      @cols = ENV['COLUMNS']&.to_i || 80
    end
    
    if @split_view
      # Split view layout - no header, more space for content
      split_width = @cols / 2
      # Main content panes - use nil colors to act as pass-through for pre-colored text
      # This is how RTFM works - it passes colored command output to panes with nil colors
      @main = Pane.new(1, 1, split_width - 1, @rows - 1, nil, nil)
      @split_pane = Pane.new(split_width + 1, 1, split_width - 1, @rows - 1, nil, nil)
      @footer = Pane.new(1, @rows, @cols, 1, 15, 8)

      # Add separator with explicit background to overwrite emoji overflow
      @separator = Pane.new(split_width, 1, 1, @rows - 1, 15, 0)
      # Build separator with explicit clearing
      separator_lines = []
      (@rows - 1).times do
        separator_lines << "│"
      end
      @separator.text = separator_lines.join("\n")
      @separator.refresh
    else
      # Single view layout - no header, more space for content
      # Use nil colors like RTFM to avoid ANSI wrapping issues
      # This prevents the corruption that happens with narrow terminals
      @main = Pane.new(1, 1, @cols, @rows - 1, nil, nil)
      @footer = Pane.new(1, @rows, @cols, 1, 15, 8)
    end
  end
  
  def setup_resize_handler
    # Catch terminal resize signal
    Signal.trap('WINCH') do
      refresh_on_resize
    end
  rescue
    # Ignore if signal handling not available on this platform
  end
  
  def refresh_on_resize
    # Get new terminal dimensions
    if IO.console
      @rows, @cols = IO.console.winsize
    else
      @rows = ENV['LINES']&.to_i || 24
      @cols = ENV['COLUMNS']&.to_i || 80
    end
    
    # Reinitialize UI with new dimensions
    setup_ui
    
    # Force full redraw
    render
  rescue
    # Ignore errors during resize to prevent crashes
  end
  
  def load_file(file)
    @items = []
    @encrypted_lines = {}
    @config_line = nil  # Reset config line before loading
    
    # Read file content
    content = File.read(file) rescue ""
    
    # Clear undo/redo stacks when loading a new file
    @undo_stack = []
    @undo_position = []
    @redo_stack = []
    @redo_position = []
    
    # Parse config line if present (before processing content)
    parse_config_line(content)
    
    # Check if file is encrypted (dot file or encrypted content)
    is_encrypted = false
    if is_encrypted_file?(file)
      if content.start_with?("ENC:")
        # Whole file is encrypted
        decrypted_content = decrypt_file(content)
        if decrypted_content.nil?
          @message = "Failed to decrypt file"
          @items = [{"text" => "Failed to decrypt file", "level" => 0, "fold" => false}]
          return
        end
        lines = decrypted_content.split("\n")
        @message = "File decrypted successfully (folded for privacy)"
        is_encrypted = true
      else
        # Dot file but not encrypted yet - just load normally
        lines = content.split("\n")
      end
    else
      lines = content.split("\n")
    end
    
    # Auto-detect indentation from the file
    detect_indentation(lines)
    
    # Check if file is large
    large_file = lines.length > 10000
    
    if large_file
      @message = "Loading large file (#{lines.length} lines)..."
      render_footer
    end
    
    # Process lines with optional progress updates for large files
    lines.each_with_index do |line, idx|
      next if line.strip.empty?
      
      # Skip config lines (don't add them to items)
      if line.strip =~ /^\(\(.+\)\)$/
        next
      end
      
      # Check if this is a continuation line for a multi-line item
      # According to HyperList spec: continuation lines start with space after the indent
      is_continuation = false
      if @items.length > 0
        last_item = @items.last
        # Check if previous item started with + (multi-line indicator)
        if last_item["text"].strip.start_with?("+")
          # For continuation lines, we expect: same indent level + one space prefix
          # Calculate the expected spaces for a continuation line
          expected_spaces = last_item["level"] * @indent_size + 1
          actual_spaces = line[/^ */].length
          
          # Check if this matches the continuation pattern
          if actual_spaces == expected_spaces
            # This is a continuation line - append it to the previous item
            continuation_text = line[expected_spaces..-1] || ""
            last_item["text"] += "\n " + continuation_text
            next  # Skip adding as a new item
          end
        end
      end
      
      # Detect level based on leading whitespace
      if line.start_with?("\t")
        # Tab-based indentation
        level = line[/^\t*/].length
      else
        # Space-based indentation
        spaces = line[/^ */].length
        level = @indent_size > 0 ? spaces / @indent_size : 0
      end
      
      text = line.strip
      
      # Track encrypted lines
      if text.start_with?("ENC:")
        @encrypted_lines[@items.length] = true
      end
      
      @items << {"text" => text, "level" => level, "fold" => false}
      
      # Update progress for large files
      if large_file && idx % 1000 == 0
        progress = (idx.to_f / lines.length * 100).to_i
        @message = "Loading... #{progress}%"
        render_footer
      end
    end
    
    @items = [{"text" => "Empty file", "level" => 0, "fold" => false}] if @items.empty?
    
    # Auto-fold for privacy/security on encrypted files
    if is_encrypted
      @fold_level = 0  # Set fold level to 0 (everything folded)
      # Fold all items that have children
      @items.each_with_index do |item, idx|
        if has_children?(idx, @items)
          item["fold"] = true
        end
      end
    end
    
    # Auto-fold deep levels for large files
    if large_file
      auto_fold_deep_levels(3)  # Auto-fold everything deeper than level 3
      @message = "Large file loaded. Deep levels auto-folded for performance."
    end
    
    # Apply configured fold level if set (after items are loaded)
    if @fold_level != 99 && !is_encrypted  # Don't override encrypted file folding
      apply_fold_level(@fold_level)
      @message = "Applied fold level: #{@fold_level}" if @message.nil? || @message.empty?
    end
    
    # Update recent files list
    add_to_recent_files(File.expand_path(file)) if file
  end
  
  def auto_fold_deep_levels(max_level)
    @items.each_with_index do |item, idx|
      if item["level"] >= max_level && has_children?(idx, @items)
        item["fold"] = true
      end
    end
  end
  
  def apply_fold_level(level)
    # Apply fold level: 0 = all folded, 99 = all open
    # Show items up to and including the specified level
    # Fold items at levels greater than specified level
    @items.each_with_index do |item, idx|
      if has_children?(idx, @items)
        # Fold if item level is greater than or equal to the fold level
        # This means: fold_level=1 shows level 0 expanded, level 1 and deeper folded
        # fold_level=2 shows levels 0-1 expanded, level 2 and deeper folded
        item["fold"] = item["level"] >= level
      end
    end
    
    # Special cases
    if level == 0
      # Fold everything that has children
      @items.each_with_index do |item, idx|
        item["fold"] = true if has_children?(idx, @items)
      end
    elsif level >= 99
      # Unfold everything
      @items.each { |item| item["fold"] = false }
    end
  end
  
  def parse_config_line(content)
    # Look for config line at the bottom of the file
    # Format: ((option1=value, option2=value))
    lines = content.split("\n")
    
    # Check last 10 lines for config (in case there are empty lines or other content)
    config_line = nil
    lines.last(10).each do |line|
      # Allow indented config lines
      if line.strip =~ /^\(\((.+)\)\)$/
        @config_line = line.strip  # Store the full line to preserve when saving
        config_line = $1
        break
      end
    end
    
    return unless config_line
    
    # Parse options (comma-separated)
    config_options = {}
    config_line.split(',').each do |option|
      option = option.strip
      if option =~ /(\w+)=(.+)/
        key = $1.strip
        value = $2.strip
        # Convert values to appropriate types
        case key
        when "fold_level", "auto_save_interval", "tab_width"
          config_options[key] = value.to_i
        when "auto_save", "wrap", "show_numbers", "highlight_current", "checkbox_date", "backup", "encrypt"
          config_options[key] = value.downcase == "true" || value.downcase == "yes"
        else
          config_options[key] = value
        end
      end
    end
    
    # Apply config options
    apply_config(config_options)
  end
  
  def apply_config(options)
    # Apply configuration options from config line
    options.each do |key, value|
      case key
      when "fold_level"
        @fold_level = value if value >= 0 && value <= 99
      when "auto_save"
        @auto_save_enabled = value
      when "auto_save_interval"
        @auto_save_interval = value if value > 0
      when "tab_width", "indent_size"
        @indent_size = value if value >= 2 && value <= 8
      when "presentation_mode", "presentation"
        @presentation_mode = value
        setup_ui if value  # Refresh UI if entering presentation mode
      when "default_view"
        case value
        when "split"
          @split_view = true
          setup_ui
        when "presentation"
          @presentation_mode = true
          setup_ui
        end
      when "theme"
        # Apply theme setting
        @theme = value if ["light", "normal", "dark"].include?(value)
      when "wrap"
        @wrap = value
      when "show_numbers"
        @show_numbers = value
      when "search_case"
        @search_case = value  # sensitive/insensitive/smart
      when "backup"
        @backup_enabled = value
      when "encrypt"
        # Handle encryption enabling (would need password prompt)
        @encrypt_enabled = value
      end
    end
    
    # Show message about applied config
    if options.any?
      # Build message showing what was applied
      msg_parts = []
      msg_parts << "fold_level=#{@fold_level}" if @fold_level != 99
      msg_parts << "theme=#{@theme}" if options["theme"]
      msg_parts << "wrap=#{@wrap ? 'yes' : 'no'}" if options.key?("wrap")
      msg_parts << "auto_save=#{@auto_save_enabled ? 'yes' : 'no'}" if options.key?("auto_save")
      
      @message = "Applied config: #{msg_parts.join(', ')}" if msg_parts.any?
      # Set a longer timeout for config message
      @message_timeout = Time.now + 5.0
    end
  end
  
  def add_to_recent_files(filepath)
    return unless filepath && File.exist?(filepath)
    
    # Load existing recent files
    recent = load_recent_files
    
    # Remove if already exists and add to front
    recent.delete(filepath)
    recent.unshift(filepath)
    
    # Keep only last 20 files
    recent = recent[0...20]
    
    # Save back to file
    File.open(@recent_files_path, 'w') do |f|
      recent.each { |path| f.puts(path) }
    end
  rescue => e
    # Silently fail if can't write recent files
  end
  
  def load_recent_files
    return [] unless File.exist?(@recent_files_path)
    
    File.readlines(@recent_files_path).map(&:strip).select do |path|
      File.exist?(path)
    end
  rescue
    []
  end
  
  def load_command_history
    history_file = File.expand_path("~/.hyperlist_command_history")
    return [] unless File.exist?(history_file)
    
    File.readlines(history_file).map(&:strip).reject(&:empty?).last(100)
  rescue
    []
  end
  
  def save_command_history
    history_file = File.expand_path("~/.hyperlist_command_history")
    File.open(history_file, 'w') do |f|
      @command_history.last(100).each { |cmd| f.puts(cmd) }
    end
  rescue
    # Silently fail if can't write history
  end
  
  def show_recent_files
    recent = load_recent_files
    
    if recent.empty?
      @message = "No recent files"
      return
    end
    
    # Save current state
    saved_items = @items.dup
    saved_current = @current
    saved_offset = @offset
    saved_filename = @filename
    saved_modified = @modified
    
    # Create items for recent files display
    @items = []
    @items << {"text" => "RECENT FILES (press Enter to open, q to cancel)", "level" => 0, "fold" => false, "raw" => true}
    @items << {"text" => "="*50, "level" => 0, "fold" => false, "raw" => true}
    
    recent.each_with_index do |path, idx|
      display_path = path.sub(ENV['HOME'], '~') if ENV['HOME']
      display_path ||= path
      @items << {"text" => "#{idx+1}. #{display_path}", "level" => 0, "fold" => false, "path" => path, "raw" => true}
    end
    
    @current = 2  # Start at first file
    @offset = 0
    @modified = false
    
    # Recent files viewer loop
    loop do
      render_main
      @footer.text = "Recent Files | Enter: open | q: cancel | j/k: navigate"
      @footer.refresh
      
      c = getchr
      case c
      when "q", "ESC"
        # Restore original state
        @items = saved_items
        @current = saved_current
        @offset = saved_offset
        @filename = saved_filename
        @modified = saved_modified
        break
      when "j", "DOWN"
        move_down if @current < @items.length - 1
      when "k", "UP"
        move_up if @current > 2  # Don't go above first file
      when "ENTER", "l"
        if @current >= 2 && @items[@current]["path"]
          selected_file = @items[@current]["path"]
          if saved_modified
            @items = saved_items
            @current = saved_current
            @offset = saved_offset
            @filename = saved_filename
            @modified = saved_modified
            @message = "Unsaved changes! Save first before opening another file"
            break
          else
            @filename = File.expand_path(selected_file)
            load_file(@filename)
            @current = 0
            @offset = 0
            @modified = false
            break
          end
        end
      when /^[1-9]$/
        # Allow number key selection
        idx = c.to_i - 1
        if idx < recent.length
          selected_file = recent[idx]
          if saved_modified
            @items = saved_items
            @current = saved_current
            @offset = saved_offset
            @filename = saved_filename
            @modified = saved_modified
            @message = "Unsaved changes! Save first before opening another file"
            break
          else
            @filename = File.expand_path(selected_file)
            load_file(@filename)
            @current = 0
            @offset = 0
            @modified = false
            break
          end
        end
      end
    end
  end
  
  def save_file
    return unless @filename
    
    # Prepare content
    content = @items.map do |item|
      # Handle multi-line items (those with embedded newlines)
      if item["text"].include?("\n")
        lines = item["text"].split("\n")
        first_line = (' ' * @indent_size) * item["level"] + lines[0]
        # Continuation lines get the same indent + space prefix
        continuation_lines = lines[1..-1].map do |line|
          (' ' * @indent_size) * item["level"] + line
        end
        [first_line, *continuation_lines].join("\n")
      else
        (' ' * @indent_size) * item["level"] + item["text"]
      end
    end.join("\n")
    
    # Append config line if present
    if @config_line && !@config_line.empty?
      # Ensure there's a blank line before config
      content += "\n" unless content.end_with?("\n")
      content += "\n" + @config_line
    else
      if @fold_level != 99
        # Rebuild config line if we have config settings but no line
        update_config_line
        if @config_line && !@config_line.empty?
          content += "\n" unless content.end_with?("\n")
          content += "\n" + @config_line
        end
      end
    end
    
    # Check if this should be an encrypted file
    if is_encrypted_file?(@filename) && !content.empty?
      # Check if any lines are already encrypted
      has_encrypted_lines = @items.any? { |item| item["text"].start_with?("ENC:") }
      
      if !has_encrypted_lines
        # Ask if user wants to encrypt the whole file
        @footer.text = "Encrypt entire file? (y/n): "
        @footer.refresh
        response = getchr
        
        if response.downcase == 'y'
          encrypted_content = encrypt_file(content)
          if encrypted_content
            File.write(@filename, encrypted_content)
            @message = "File saved (encrypted)"
          else
            @message = "Encryption cancelled - file not saved"
            return
          end
        else
          # Save as plain text even though it's a dot file
          File.write(@filename, content)
          @message = "Saved to #{@filename} (unencrypted)"
        end
      else
        # Has encrypted lines, save as is
        File.write(@filename, content)
        @message = "Saved to #{@filename}"
      end
    else
      # Regular file, save normally
      File.write(@filename, content)
      @message = "Saved to #{@filename}"
    end
    
    @modified = false
    @last_auto_save = Time.now if @auto_save_enabled
  end
  
  def check_auto_save
    return unless @filename && @modified
    
    if Time.now - @last_auto_save >= @auto_save_interval
      save_file
      @message = "Auto-saved to #{@filename}"
      @last_auto_save = Time.now
    end
  end
  
  def export_to(format, export_file = nil)
    # Generate default filename if not provided
    if export_file.nil? || export_file.empty?
      base = @filename ? File.basename(@filename, '.*') : 'hyperlist'
      extension = case format
                  when 'md', 'markdown' then '.md'
                  when 'html' then '.html'
                  when 'txt', 'text' then '.txt'
                  end
      export_file = base + extension
    end
    
    content = case format
              when 'md', 'markdown'
                export_to_markdown
              when 'html'
                export_to_html
              when 'txt', 'text'
                export_to_text
              end
    
    File.open(export_file, 'w') { |f| f.write(content) }
    @message = "Exported to #{export_file}"
  rescue => e
    @message = "Export failed: #{e.message}"
  end
  
  def export_to_markdown
    lines = []
    @items.each do |item|
      text = item["text"]
      level = item["level"]
      
      # Convert HyperList bold/italic to Markdown format
      # In HyperList: *text* is bold, /text/ is italic, _text_ is underline
      # In Markdown: **text** is bold, *text* is italic, no standard underline
      
      # First, temporarily replace escaped characters to avoid conflicts
      text = text.gsub('\\*', '\u0001')
                 .gsub('\\/', '\u0002')
                 .gsub('\\_', '\u0003')
      
      # Convert HyperList formatting to Markdown
      # Bold: *text* -> **text**
      text = text.gsub(/\*([^*]+)\*/, '**\1**')
      
      # Italic: /text/ -> *text*
      text = text.gsub(/\/([^\/]+)\//, '*\1*')
      
      # Underline: _text_ -> ***text*** (bold+italic as markdown doesn't have underline)
      text = text.gsub(/_([^_]+)_/, '***\1***')
      
      # Restore escaped characters
      text = text.gsub('\u0001', '\\*')
                 .gsub('\u0002', '\\/')
                 .gsub('\u0003', '\\_')
      
      # Convert checkboxes to markdown format
      text = text.gsub(/^\[X\]/i, '- [x]')
                 .gsub(/^\[O\]/, '- [ ] *(in progress)*')
                 .gsub(/^\[-\]/, '- [ ] *(partial)*')
                 .gsub(/^\[ \]/, '- [ ]')
                 .gsub(/^\[_\]/, '- [ ]')
      
      # Handle different levels with proper markdown indentation
      if level == 0 && !text.start_with?('- [')
        lines << "# #{text}" unless text.empty?
      elsif level == 1 && !text.start_with?('- [')
        lines << "## #{text}" unless text.empty?
      else
        # Use spaces for indentation in lists
        indent = ' ' * (@indent_size * [level - 2, 0].max)
        if text.start_with?('- [')
          lines << indent + text
        else
          lines << indent + "- #{text}"
        end
      end
    end
    lines.join("\n")
  end
  
  def export_to_html
    html = <<~HTML
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>#{@filename ? File.basename(@filename, '.*') : 'HyperList'}</title>
        <style>
          body { 
            font-family: 'Courier New', monospace; 
            margin: 20px; 
            background-color: white;
            color: #333;
            white-space: pre;
            line-height: 1.3;
          }
          /* Based on HyperList LaTeX color definitions */
          .checked { color: #00cc00; }  /* bright green */
          .in-progress { color: #00cc00; }  /* bright green */
          .partial { color: #008800; }  /* medium green */
          .unchecked { color: #004400; }  /* dark green */
          .qualifier { color: #008000; }  /* green */
          .operator { color: #0000cc; font-weight: bold; }  /* blue */
          .property { color: #cc0000; }  /* red */
          .reference { color: #800080; }  /* violet */
          .tag { color: #cc9900; }  /* orange */
          .timestamp { color: #cc0000; }  /* red - it's a property */
          .comment { color: #008080; font-style: italic; }  /* turquoise */
          strong { font-weight: bold; }
          em { font-style: italic; }
          u { text-decoration: underline; }
        </style>
      </head>
      <body>
    HTML
    
    @items.each do |item|
      original_text = item["text"]
      level = item["level"]
      indent = ' ' * (@indent_size * level)
      
      # Process the line
      # We'll apply formatting BEFORE escaping HTML entities
      text = original_text
      
      # Apply all formatting with placeholder markers
      # Use unique markers that won't appear in normal text
      
      # Markdown formatting MUST come first before other replacements
      # Bold *text*
      text = text.gsub(/\*([^*]+)\*/) do
        "\u0001BOLDSTART\u0002#{$1}\u0001BOLDEND\u0002"
      end
      
      # Italic /text/
      text = text.gsub(/\/([^\/]+)\//) do
        "\u0001ITALICSTART\u0002#{$1}\u0001ITALICEND\u0002"
      end
      
      # Underline _text_
      text = text.gsub(/_([^_]+)_/) do
        "\u0001UNDERSTART\u0002#{$1}\u0001UNDEREND\u0002"
      end
        
        # Checkboxes at start
        text = text.sub(/^\[X\]/i, "\u0001CBCHECKED\u0002")
                   .sub(/^\[O\]/, "\u0001CBPROGRESS\u0002")
                   .sub(/^\[-\]/, "\u0001CBPARTIAL\u0002")
                   .sub(/^\[ \]/, "\u0001CBUNCHECKED\u0002")
                   .sub(/^\[_\]/, "\u0001CBUNCHECKED2\u0002")
        
        # Timestamps
        text = text.gsub(/(\d{4}-\d{2}-\d{2} \d{2}\.\d{2}):/) do
          "\u0001TSSTART\u0002#{$1}\u0001TSEND\u0002:"
        end
        
        # Qualifiers [text] - but not checkboxes
        unless text.include?("\u0001CB")
          text = text.gsub(/\[([^\]]+)\]/) do
            "\u0001QSTART\u0002[#{$1}]\u0001QEND\u0002"
          end
        end
        
        # References <text>
        text = text.gsub(/<([^>]+)>/) do
          "\u0001REFSTART\u0002<#{$1}>\u0001REFEND\u0002"
        end
        
        # Properties (Word: )
        text = text.gsub(/\b([A-Z][a-z][a-zA-Z]*): /) do
          "\u0001PROPSTART\u0002#{$1}: \u0001PROPEND\u0002"
        end
        
        # Operators (CAPS:)
        text = text.gsub(/\b([A-Z][A-Z]+):/) do
          "\u0001OPSTART\u0002#{$1}:\u0001OPEND\u0002"
        end
        
        # Hash tags
        text = text.gsub(/#(\w+)/) do
          "\u0001TAGSTART\u0002##{$1}\u0001TAGEND\u0002"
        end
        
        # Now escape HTML entities
        text = text.gsub('&', '&amp;')
                   .gsub('<', '&lt;')
                   .gsub('>', '&gt;')
                   .gsub('"', '&quot;')
                   .gsub("'", '&#39;')
        
        # Replace markers with HTML tags
        text = text.gsub("\u0001CBCHECKED\u0002", '<span class="checked">[X]</span>')
                   .gsub("\u0001CBPROGRESS\u0002", '<span class="in-progress">[O]</span>')
                   .gsub("\u0001CBPARTIAL\u0002", '<span class="partial">[-]</span>')
                   .gsub("\u0001CBUNCHECKED\u0002", '<span class="unchecked">[ ]</span>')
                   .gsub("\u0001CBUNCHECKED2\u0002", '<span class="unchecked">[_]</span>')
                   .gsub("\u0001TSSTART\u0002", '<span class="timestamp">')
                   .gsub("\u0001TSEND\u0002", '</span>')
                   .gsub("\u0001QSTART\u0002", '<span class="qualifier">')
                   .gsub("\u0001QEND\u0002", '</span>')
                   .gsub("\u0001REFSTART\u0002", '<span class="reference">')
                   .gsub("\u0001REFEND\u0002", '</span>')
                   .gsub("\u0001PROPSTART\u0002", '<span class="property">')
                   .gsub("\u0001PROPEND\u0002", '</span>')
                   .gsub("\u0001OPSTART\u0002", '<span class="operator">')
                   .gsub("\u0001OPEND\u0002", '</span>')
                   .gsub("\u0001TAGSTART\u0002", '<span class="tag">')
                   .gsub("\u0001TAGEND\u0002", '</span>')
                   .gsub("\u0001BOLDSTART\u0002", '<strong>')
                   .gsub("\u0001BOLDEND\u0002", '</strong>')
                   .gsub("\u0001ITALICSTART\u0002", '<em>')
                   .gsub("\u0001ITALICEND\u0002", '</em>')
                   .gsub("\u0001UNDERSTART\u0002", '<u>')
                   .gsub("\u0001UNDEREND\u0002", '</u>')
        
        html += indent + text + "\n"
    end
    
    html += "</body>\n</html>"
    html
  end
  
  def export_to_text
    lines = []
    @items.each do |item|
      indent = ' ' * (@indent_size * item["level"])
      lines << indent + item["text"]
    end
    lines.join("\n")
  end
  
  def render
    render_main
    render_split_pane if @split_view
    render_footer
    # Force redraw separator column to fix emoji overflow
    if @split_view
      split_col = @cols / 2
      # Clear and redraw the entire separator column
      (@rows - 1).times do |row|
        # Move to position and draw separator with background color to overwrite anything
        print "\e[#{row + 1};#{split_col}H\e[48;5;0m│\e[49m"
      end
    end
  end
  
  
  def wrap_line(text, width, indent_level)
    # Wrap a line per HyperList spec:
    # Multi-line items start with '+' on first line
    # Continuation lines have just a space prefix
    return [text] unless @wrap
    
    # Calculate effective width (account for indent and fold indicators)
    indent_width = @indent_size * indent_level + 2  # +2 for fold indicator
    effective_width = width - indent_width - 5  # Extra margin for readability
    
    return [text] if text.length <= effective_width || effective_width <= 10
    
    wrapped = []
    remaining = text.dup
    first_line = true
    
    # Check if line already starts with + (multi-line indicator)
    has_plus = text.strip.start_with?('+')
    if has_plus
      # Remove the + for processing, we'll add it back
      remaining = remaining.sub(/^\s*\+\s*/, '')
    end
    
    while remaining && !remaining.empty?
      if first_line
        # First line gets the multi-line indicator if needed
        if remaining.length <= effective_width
          # If line already had +, it was removed earlier, so we add it back
          # If line didn't have + but needs wrapping (wrapped.any?), add +
          # Otherwise, leave as is
          if has_plus
            wrapped << "+ #{remaining}"
          elsif wrapped.any?
            wrapped << "+ #{remaining}"
          else
            wrapped << remaining
          end
          break
        else
          # Find a good break point (prefer spaces)
          break_point = remaining[0...effective_width].rindex(' ') || effective_width
          line_text = remaining[0...break_point].rstrip
          # Add + to first line of multi-line items
          wrapped << "+ #{line_text}"
          remaining = remaining[break_point..-1].lstrip
          first_line = false
        end
      else
        # Continuation lines get just a space prefix per HyperList spec
        cont_width = effective_width - 1  # Account for space prefix
        if remaining.length <= cont_width
          wrapped << " #{remaining}"
          break
        else
          break_point = remaining[0...cont_width].rindex(' ') || cont_width
          wrapped << " #{remaining[0...break_point].rstrip}"
          remaining = remaining[break_point..-1].lstrip
        end
      end
    end
    
    wrapped
  end
  
  def render_main
    visible_items = get_visible_items
    
    # Build ALL lines for the pane (like RTFM/IMDB do)
    lines = []
    in_literal_block = false
    literal_start_level = -1
    
    # Track which line number each item starts at (for scroll calculation)
    item_line_starts = {}
    
    visible_items.each_with_index do |item, idx|
      next unless item
      
      # Record where this item starts in the display
      item_line_starts[idx] = lines.length
      
      # Handle line wrapping and multi-line items
      # First, split by embedded newlines (from multi-line items with + indicator)
      embedded_lines = item["text"].split("\n")
      text_lines = []
      
      embedded_lines.each do |embedded_line|
        if @wrap
          # Wrap each embedded line separately
          wrapped = wrap_line(embedded_line, @cols, item["level"])
          text_lines.concat(wrapped)
        else
          text_lines << embedded_line
        end
      end
      
      text_lines.each_with_index do |text_line, line_idx|
        # Get the actual line number from the real index in @items
        real_idx = get_real_index(item)
        actual_line_number = real_idx ? real_idx + 1 : 0  # +1 for 1-based line numbers
        
        # Add line number if enabled (only on first line of wrapped text)
        line = ""
        if @show_numbers
          if line_idx == 0
            line = "#{actual_line_number.to_s.rjust(4)} "
          else
            line = "     "  # Empty space for continuation lines
          end
        end
        
        line += ' ' * (@indent_size * item["level"])
        
        # Add fold indicator only on first line
        if line_idx == 0
          real_idx = get_real_index(item)
          if real_idx && has_children?(real_idx, @items) && item["fold"]
            color = (@presentation_mode && !is_item_in_presentation_focus?(item)) ? "240" : "245"
            line += "▶".fg(color) + " "
          elsif real_idx && has_children?(real_idx, @items)
            color = (@presentation_mode && !is_item_in_presentation_focus?(item)) ? "240" : "245"
            line += "▷".fg(color) + " "
          else
            line += "  "
          end
        else
          # Continuation lines already have their space prefix from wrap_line
          line += "  "  # Just add fold indicator spacing
        end
        
        # Handle literal blocks and syntax highlighting
        if item["text"].strip == "\\"
          if !in_literal_block
            in_literal_block = true
            literal_start_level = item["level"]
            spaces = text_line.match(/^(\s*)/)[1] || ""
            line += spaces + "\\".fg("3")
          elsif item["level"] == literal_start_level
            in_literal_block = false
            literal_start_level = -1
            spaces = text_line.match(/^(\s*)/)[1] || ""
            line += spaces + "\\".fg("3")
          else
            line += text_line
          end
        elsif in_literal_block
          line += text_line
        else
          # Normal syntax highlighting
          has_match = @search_matches.include?(idx) && @search && !@search.empty?
          if @presentation_mode && !is_item_in_presentation_focus?(item)
            line += text_line.fg("240")
          else
            line += process_text(text_line, has_match)
          end
        end
        
        # Apply current item highlighting (all lines of wrapped text get bg)
        if idx == @current
          # Skip background highlighting in presentation mode for items in focus
          if !(@presentation_mode && is_item_in_presentation_focus?(item))
            bg_color = (!@split_view || @active_pane == :main) ? "237" : "234"
            if bg_color
              # Pad line to full width and apply background
              padded_line = line + " " * [@cols - line.pure.length, 0].max
              bg_code = "\e[48;5;#{bg_color}m"
              reset_bg = "\e[49m"
              line = bg_code + padded_line.gsub(/\e\[49m/, '') + reset_bg
            end
          end
        end
        
        lines << line
      end
      
      # Check if exiting literal block
      if in_literal_block && item["level"] <= literal_start_level && !item["text"].strip == "\\"
        in_literal_block = false
        literal_start_level = -1
      end
    end
    
    # Add a blank line at the bottom to show end of document
    lines << ""
    
    # Set the full content to the pane and let rcurses handle scrolling
    @main.text = lines.join("\n")
    
    # Calculate how many extra lines are created by wrapping
    logical_lines = lines.length
    # Estimate wrapped lines by checking line lengths against pane width
    extra_wrapped_lines = 0
    lines[0..-2].each do |line|  # Exclude the blank line we added
      # Remove ANSI codes for length calculation
      clean_line = line.gsub(/\e\[[0-9;]*m/, '')
      if clean_line.length > @main.w
        # This line will wrap - calculate how many extra lines it creates
        extra_lines = (clean_line.length.to_f / @main.w).ceil - 1
        extra_wrapped_lines += extra_lines
      end
    end
    
    # Calculate scroll position based on actual line positions, not item indices
    # The current item starts at line item_line_starts[@current]
    scrolloff = 3
    total_lines = lines.length  # Total number of actual display lines
    page = @main.h  # Height of the display area
    
    # Get the actual line where the current item starts
    current_line = item_line_starts[@current] || 0
    
    if total_lines <= page
      # If everything fits, always start from the very top
      @main.ix = 0
    elsif current_line - @main.ix < scrolloff
      # If we're too close to the top of the pane, scroll up
      @main.ix = [current_line - scrolloff, 0].max
    elsif (@main.ix + page - 1 - current_line) < scrolloff
      # If we're too close to the bottom of the pane, scroll down
      # Make sure we don't scroll past the last line
      max_scroll = [total_lines - page, 0].max
      @main.ix = [current_line + scrolloff - page + 1, max_scroll].min
    end
    
    @main.refresh
  end
  
  def get_theme_colors
    # Theme definitions based on HyperList spec colors
    # Using hex RGB colors (RRGGBB format) for rcurses
    # Per HyperList spec from hyperlist.tex:
    # red (properties/dates), green (qualifiers/states), blue (operators)
    # magenta/violet (references), cyan (parentheses/quotes), yellow (literals)
    # orange (tags)
    case @theme
    when "light"
      # Brighter, more saturated colors for dark terminals
      {
        "red" => "FF5050",       # Bright red for properties
        "green" => "50FF50",     # Bright green for qualifiers  
        "blue" => "6496FF",      # Bright blue for operators
        "magenta" => "C864FF",   # Light purple/violet for references
        "cyan" => "50FFFF",      # Bright cyan for parentheses
        "yellow" => "FFFF64",    # Bright yellow for literals
        "orange" => "FFB450",    # Bright orange for tags
        "gray" => "C8C8C8"       # Light gray
      }
    when "dark"
      # Darker, less saturated colors for light background terminals
      {
        "red" => "B40000",       # Dark red for properties
        "green" => "008C00",     # Dark green for qualifiers
        "blue" => "0000B4",      # Dark blue for operators  
        "magenta" => "8C008C",   # Dark purple for references
        "cyan" => "008C8C",      # Dark cyan for parentheses
        "yellow" => "8C8C00",    # Dark yellow for literals
        "orange" => "B46400",    # Dark orange for tags
        "gray" => "646464"       # Dark gray
      }
    else # normal - using 256 color codes for compatibility
      {
        "red" => "196",          # Red for properties/dates (standard red)
        "green" => "46",         # Green for qualifiers/checkboxes 
        "blue" => "21",          # Blue for operators (AND/OR/IF/THEN)
        "magenta" => "165",      # Purple/violet for references  
        "cyan" => "51",          # Cyan for parentheses/quotes
        "yellow" => "226",       # Yellow for literals/substitutions
        "orange" => "208",       # Orange for tags
        "gray" => "245"          # Gray
      }
    end
  end

  def process_text(text, highlight_search = false)
    # Work with a clean copy
    result = text.dup
    processed_checkbox = false
    colors = get_theme_colors
    
    # Config lines should never be displayed (they're filtered out)
    # But if somehow one gets through, don't process it
    if result =~ /^\(\(.+\)\)$/
      return ""
    end
    
    # If text already contains ANSI codes, return as-is to avoid double-processing
    if result.include?("\e[")
      return result
    end
    
    # Apply State and Transition underlining FIRST, before any coloring
    if @st_underline_mode == 1
      # Underline states
      if result =~ /^(\s*)(S:\s+)(.*)$/ || result =~ /^(\s*)(\|\s+)(.*)$/
        prefix = $1 || ""
        marker = $2
        content = $3 || ""
        # Apply underline to content after the marker
        result = prefix + marker + content.u
      end
    elsif @st_underline_mode == 2
      # Underline transitions
      if result =~ /^(\s*)(T:\s+)(.*)$/ || result =~ /^(\s*)(\/\s+)(.*)$/
        prefix = $1 || ""
        marker = $2
        content = $3 || ""
        # Apply underline to content after the marker
        result = prefix + marker + content.u
      end
    end
    
    # Helper method to safely apply regexes without corrupting ANSI sequences
    def safe_regex_replace(text, pattern, &block)
      # Ensure text is UTF-8 encoded
      text = text.to_s.force_encoding('UTF-8')
      
      # Find all ANSI sequences and replace with placeholders
      ansi_sequences = []
      placeholder_text = text.gsub(/\e\[[0-9;]*m/) do |match|
        ansi_sequences << match
        "⟨ANSI#{ansi_sequences.length - 1}⟩"
      end
      
      # Apply the regex to the placeholder text
      result_text = placeholder_text.gsub(pattern, &block)
      
      # Restore ANSI sequences
      ansi_sequences.each_with_index do |ansi, index|
        result_text.gsub!("⟨ANSI#{index}⟩", ansi)
      end
      
      result_text
    end
    
    # Check if this is an encrypted line
    if result.start_with?("ENC:")
      # Show encrypted indicator instead of the encrypted data
      return "🔒 [ENCRYPTED LINE - Press Ctrl-E to decrypt]".fg("196")  # Bright red
    end
    
    # Check if this is a literal block marker (single backslash)
    if result.strip == "\\"
      return result.fg(colors["yellow"])  # Yellow for literal block markers
    end
    
    # Apply search highlighting if we have an active search
    if highlight_search && @search && !@search.empty?
      # Find all occurrences of the search term (case insensitive)
      search_regex = Regexp.new(Regexp.escape(@search), Regexp::IGNORECASE)
      result.gsub!(search_regex) { |match| match.bg("220") }  # Yellow background, preserve text color
    end
    
    # Handle identifiers at the beginning (like "1.1.1.1" or "1A1A")
    # Based on hyperlist.vim: '^\(\t\|\*\)*[0-9.]* '
    if result =~ /^([0-9][0-9A-Z.]*\s)/
      identifier = $1
      result = result.sub(/^[0-9][0-9A-Z.]*\s/, identifier.fg(colors["magenta"]))  # Magenta for identifiers
    end
    
    # Handle multi-line indicator at the beginning (+ with space)
    # Based on hyperlist.vim: '^\(\t\|\*\)*+ '
    if result =~ /^\+\s/
      result = result.sub(/^(\+\s)/, "+".fg(colors["red"]) + " ")  # Red for multi-line indicator
    end
    
    # Handle continuation markers (+ at start of indented lines in References section)
    if result =~ /^\s*\+\s/
      spaces = $1 || ""
      marker = $2 || "+ "
      result = result.sub(/^(\s*)(\+\s)/, spaces + marker.fg(colors["red"]))  # Red for continuation marker
    end
    
    # Process checkboxes anywhere in the line (can have leading spaces)
    if result =~ /^(\s*)(\[X\]|\[x\])/
      spaces = $1
      colored = "[X]".fg(colors["green"])
      result = result.sub(/^(\s*)(\[X\]|\[x\])/, "#{spaces}#{colored}")  # Bright green for completed
      processed_checkbox = true
    elsif result =~ /^(\s*)(\[O\])/
      spaces = $1
      colored = "[O]".fg(colors["green"]).b
      result = result.sub(/^(\s*)(\[O\])/, "#{spaces}#{colored}")  # Bold bright green for in-progress
      processed_checkbox = true
    elsif result =~ /^(\s*)(\[-\])/
      spaces = $1
      colored = "[-]".fg(colors["green"])
      result = result.sub(/^(\s*)(\[-\])/, "#{spaces}#{colored}")  # Green for partial
      processed_checkbox = true
    elsif result =~ /^(\s*)(\[ \]|\[_\])/
      spaces = $1
      colored = "[ ]".fg(colors["green"])
      result = result.sub(/^(\s*)(\[ \]|\[_\])/, "#{spaces}#{colored}")  # Dark green for unchecked
      processed_checkbox = true
    elsif !processed_checkbox
      # Only handle other qualifiers if we didn't process a checkbox
      # Based on hyperlist.vim: '\[.\{-}\]'
      result = safe_regex_replace(result, /\[([^\]]*)\]/) do |match|
        content = match[1..-2]  # Extract content between brackets
        "[#{content}]".fg(colors["green"])  # Green for all qualifiers
      end
    end
    
    # We'll handle parentheses AFTER operators/properties to avoid conflicts
    
    # Handle date timestamps as properties (for checkbox dates)
    # Format: YYYY-MM-DD HH.MM:
    result.gsub!(/(\d{4}-\d{2}-\d{2} \d{2}\.\d{2}):/) do
      "#{$1}:".fg(colors["red"])  # Red for timestamp properties
    end
    
    # Handle operators and properties with colon pattern
    # Operators: ALL-CAPS followed by colon (with or without space)
    # Properties: Mixed case followed by colon and space
    # Modified pattern to also match after ANSI placeholders (⟨ANSI\d+⟩)
    result = safe_regex_replace(result, /(\A|\s+|⟨ANSI\d+⟩)([a-zA-Z][a-zA-Z0-9_\-() .\/=]*):(\s*)/) do |match|
      # Extract parts from the match
      if match =~ /(\A|\s+|⟨ANSI\d+⟩)([a-zA-Z][a-zA-Z0-9_\-() .\/=]*):(\s*)/
        prefix_space = $1
        text_part = $2
        space_after = $3 || ""
        colon_space = ":#{space_after}"
        
        # Check if it's an operator (ALL-CAPS with optional _, -, (), /, =, spaces)
        if text_part =~ /^[A-Z][A-Z_\-() \/=]*$/
          prefix_space + text_part.fg(colors["blue"]) + colon_space.fg(colors["blue"])  # Blue for operators (including S: and T:)
        elsif text_part.length >= 2 && space_after.include?(" ")
          # It's a property (mixed case, at least 2 chars, has space after colon)
          prefix_space + text_part.fg(colors["red"]) + colon_space.fg(colors["red"])  # Red for properties
        else
          # Leave as is
          match
        end
      else
        match
      end
    end
    
    
    # Color special state/transition markers (| and /) green
    result.gsub!(/^(\s*)\|\s+/) { $1 + "| ".fg(colors["green"]) }  # Green for pipe (state marker)
    result.gsub!(/^(\s*)\/\s+/) { $1 + "/ ".fg(colors["green"]) }  # Green for slash (transition marker)
    
    # Handle OR: at the beginning of a line (with optional spaces)
    result.sub!(/^(\s*)(OR):/) { $1 + "OR:".fg(colors["blue"]) }  # Blue for OR: at line start
    
    # Handle parentheses content (moved here to avoid conflicts with properties)
    # Based on hyperlist.vim: '(.\{-})'
    result = safe_regex_replace(result, /\(([^)]*)\)/) do |match|
      content = match[1..-2]  # Extract content between parentheses
      "(".fg(colors["cyan"]) + content.fg(colors["cyan"]) + ")".fg(colors["cyan"])
    end
    
    # Handle semicolons as separators (they separate items on the same line)
    # Semicolons are green like qualifiers
    result = safe_regex_replace(result, /;/) { ";".fg(colors["green"]) }
    
    # Handle references - color entire reference including brackets
    # Based on hyperlist.vim: '<\{1,2}[...]\+>\{1,2}'
    result.gsub!(/<{1,2}([^>]+)>{1,2}/) { |match| match.fg(colors["magenta"]) }  # Magenta for references
    
    # Handle special keywords SKIP and END
    result.gsub!(/\b(SKIP|END)\b/) { $1.fg(colors["magenta"]) }  # Magenta for special keywords (like references)
    
    # Handle quoted strings (only double quotes are special in HyperList)
    # Based on hyperlist.vim: '".\{-}"'
    result.gsub!(/"([^"]*)"/) do
      content = $1
      # Color any ## sequences inside the quotes as red
      content.gsub!(/(##[<>-]+)/) { $1.fg(colors["red"]) }
      '"'.fg(colors["cyan"]) + content.fg(colors["cyan"]) + '"'.fg(colors["cyan"])  # Cyan for quoted strings
    end
    
    # Handle change markup - all double-hashes should be red
    # First handle ##><Reference>##-> style (with reference in the middle)
    result.gsub!(/(##[<>-]+)(<[^>]+>)(##[<>-]+)/) do
      $1.fg(colors["red"]) + $2.fg(colors["magenta"]) + $3.fg(colors["red"])  # Red markers, magenta reference
    end
    
    # Handle ##Text## change info (text between double hashes)
    result.gsub!(/(##)([^#]+)(##)/) { $1.fg(colors["red"]) + $2 + $3.fg(colors["red"]) }  # Red for change info markers
    
    # Then color any remaining ## sequences red
    result.gsub!(/(##[<>-]*)/) { $1.fg(colors["red"]) }  # Red for all ## markers
    
    # Handle substitutions {variable}
    result.gsub!(/\{([^}]+)\}/) { "{".fg(colors["yellow"]) + $1.fg(colors["yellow"]) + "}".fg(colors["yellow"]) }  # Yellow for substitutions
    
    # Handle hash tags
    # Based on hyperlist.vim: '#[a-zA-Z0-9.:/_&?%=+\-\*]\+'
    result.gsub!(/#([a-zA-Z0-9.:_\/&?%=+\-*]+)/) { "##{$1}".fg(colors["orange"]) }  # Orange for tags
    
    # Handle text formatting (bold, italic, underline)
    # Based on hyperlist.vim patterns with tab/space boundaries
    # Bold: '\(\t\| \)\@<=\*.\{-}\*\($\| \)\@='
    result.gsub!(/(?<=\s|\A)\*([^*]+)\*(?=\s|\z)/) { $1.b }
    
    # Italic: '\(\t\| \)\@<=/.\{-}/\($\| \)\@='
    result.gsub!(/(?<=\s|\A)\/([^\/]+)\/(?=\s|\z)/) { $1.i }
    
    # Underline: '\(\t\| \)\@<=_.\{-}_\($\| \)\@='
    result.gsub!(/(?<=\s|\A)_([^_]+)_(?=\s|\z)/) { $1.u }
    
    result
  end
  
  def render_footer
    # Don't overwrite footer if showing password prompt
    if @footer && @footer.text && @footer.text.include?("password")
      return
    end
    
    version_text = "v#{VERSION}"
    
    if @mode == :command
      base_text = ":" + @command
    elsif @mode == :search
      base_text = "/" + @search
    elsif @mode == :insert
      base_text = "-- INSERT --"
    elsif !@message.empty?
      base_text = @message
      # Set timeout for message if not already set
      @message_timeout = Time.now + 3.0 if @message_timeout.nil?
      # Clear message after timeout
      if @message_timeout && Time.now >= @message_timeout
        @message = ""
        @message_timeout = nil
      end
    else
      # Enhanced status with file info
      filename_display = @filename ? File.basename(@filename) : "New HyperList"
      modified_indicator = @modified ? "[+]" : ""
      pos = "#{@current + 1}/#{get_visible_items.length}"
      
      # Count words in visible items
      word_count = count_words_in_items
      
      # Auto-save indicator
      auto_save_indicator = @auto_save_enabled ? "[A]" : ""
      
      # Split view indicator  
      split_indicator = @split_view ? "[#{@active_pane.upcase}]" : ""
      
      # Build status line components
      # Use full path with ~ for home directory
      full_path = @filename ? @filename.gsub(ENV['HOME'], '~') : "New HyperList"
      file_part = "#{full_path}#{modified_indicator}"
      stats_part = "L#{pos} W:#{word_count}"
      indicators = "#{auto_save_indicator}#{split_indicator}"
      right_side = "? help  #{version_text}"
      
      # Combine left elements
      left_content = indicators.empty? ? "#{file_part}   #{stats_part}" : "#{file_part}#{indicators}   #{stats_part}"
      
      # Calculate spacing between left and right
      total_length = left_content.length + right_side.length
      available_space = @cols - total_length
      
      if available_space > 0
        # Add spacing between left and right content
        base_text = "#{left_content}#{' ' * available_space}#{right_side}"
      else
        # Terminal too narrow - truncate the path if needed
        max_path_length = @cols - stats_part.length - right_side.length - modified_indicator.length - indicators.length - 6
        if max_path_length > 10
          truncated_path = full_path.length > max_path_length ? "...#{full_path[-(max_path_length-3)..-1]}" : full_path
          left_content = "#{truncated_path}#{modified_indicator}#{indicators}   #{stats_part}"
          base_text = "#{left_content}  #{right_side}"
        else
          # Very narrow - show minimal info
          base_text = "#{stats_part}  #{right_side}"
        end
      end
    end
    
    @footer.text = base_text
    
    @footer.refresh
  end
  
  def count_words_in_items
    visible = get_visible_items
    total_words = 0
    visible.each do |item|
      # Count words in plain text (remove markup)
      text = item["text"].gsub(/\[[^\]]*\]/, '')  # Remove brackets
      text = text.gsub(/<[^>]*>/, '')  # Remove references
      text = text.gsub(/[*\/_]/, '')  # Remove formatting
      words = text.split(/\s+/).reject(&:empty?)
      total_words += words.length
    end
    total_words
  end
  
  def get_visible_items
    visible = []
    skip_until = -1
    
    @items.each_with_index do |item, idx|
      if idx <= skip_until
        next
      end
      
      # Store the item with its real index to avoid lookup issues
      item_with_index = item.dup
      item_with_index["_real_index"] = idx
      visible << item_with_index
      
      if item["fold"] && has_children?(idx, @items)
        # Skip children if folded
        level = item["level"]
        skip_until = idx
        ((idx + 1)...@items.length).each do |j|
          if @items[j]["level"] <= level
            break
          end
          skip_until = j
        end
      end
    end
    
    visible
  end
  
  # Helper method to get the real index from a visible item
  def get_real_index(visible_item)
    return nil unless visible_item
    visible_item["_real_index"] || @items.index(visible_item)
  end
  
  def has_children?(idx, items)
    return false if idx >= items.length - 1
    return false if idx < 0

    current_item = items[idx]
    next_item = items[idx + 1]

    # For visible items array
    if current_item.is_a?(Hash) && next_item.is_a?(Hash)
      return next_item["level"] > current_item["level"]
    end

    false
  end

  def should_move_with_children?
    if @split_view && @active_pane == :split
      # Handle split pane
      visible_items = get_visible_split_items
      return false if @split_current >= visible_items.length

      item = visible_items[@split_current]
      real_idx = @split_items.index(item)

      # Move with children only if item is folded (collapsed) and has children
      return real_idx && has_children_in_array?(real_idx, @split_items) && item["fold"]
    else
      # Handle main pane
      visible = get_visible_items
      return false if @current >= visible.length

      item = visible[@current]
      real_idx = get_real_index(item)

      # Move with children only if item is folded (collapsed) and has children
      return real_idx && has_children?(real_idx, @items) && @items[real_idx]["fold"]
    end
  end

  def get_last_descendant_index(idx, items)
    # Find the index after the last descendant of item at idx
    # Returns idx + 1 if no children
    return idx + 1 if idx >= items.length - 1
    return idx + 1 unless has_children?(idx, items)

    current_level = items[idx]["level"]
    last_idx = idx + 1

    while last_idx < items.length && items[last_idx]["level"] > current_level
      last_idx += 1
    end

    last_idx
  end
  
  def indent_split_right(with_children = false)
    visible_items = get_visible_split_items
    return if @split_current >= visible_items.length
    
    item = visible_items[@split_current]
    real_idx = @split_items.index(item)
    
    # Can only indent if there's a previous item at same or higher level
    if real_idx && real_idx > 0
      save_undo_state  # Save state before modification
      original_level = item["level"]
      item["level"] += 1  # Since item is a reference, this updates the object in both arrays
      
      # Indent children if requested
      if with_children
        ((real_idx + 1)...@split_items.length).each do |i|
          if @split_items[i]["level"] > original_level
            @split_items[i]["level"] += 1
          else
            break
          end
        end
      end
      
      @modified = true
      @message = "Indented in split pane"
    end
  end
  
  def indent_split_left(with_children = false)
    visible_items = get_visible_split_items
    return if @split_current >= visible_items.length
    
    item = visible_items[@split_current]
    real_idx = @split_items.index(item)
    
    if real_idx && item["level"] > 0
      save_undo_state  # Save state before modification
      original_level = item["level"]
      item["level"] -= 1  # Since item is a reference, this updates the object in both arrays
      
      # Unindent children if requested
      if with_children
        ((real_idx + 1)...@split_items.length).each do |i|
          if @split_items[i]["level"] > original_level
            @split_items[i]["level"] -= 1
          else
            break
          end
        end
      end
      
      @modified = true
      @message = "Unindented in split pane"
    end
  end
  
  def toggle_fold
    if @split_view && @active_pane == :split
      # Handle fold toggle in split pane
      visible_items = get_visible_split_items
      return if @split_current >= visible_items.length
      
      item = visible_items[@split_current]
      real_idx = @split_items.index(item)
      
      if real_idx && has_children_in_array?(real_idx, @split_items)
        item["fold"] = !item["fold"]  # Since item is a reference, this updates the object in both arrays
      end
    else
      # Handle fold toggle in main pane
      visible = get_visible_items
      return if @current >= visible.length
      
      item = visible[@current]
      real_idx = get_real_index(item)
      
      if real_idx && has_children?(real_idx, @items)
        @items[real_idx]["fold"] = !@items[real_idx]["fold"]
        record_last_action(:toggle_fold, nil)
      end
    end
  end

  def collapse_item
    if @split_view && @active_pane == :split
      # Handle collapse in split pane
      visible_items = get_visible_split_items
      return if @split_current >= visible_items.length

      item = visible_items[@split_current]
      real_idx = @split_items.index(item)

      if real_idx && has_children_in_array?(real_idx, @split_items) && !item["fold"]
        item["fold"] = true
      end
    else
      # Handle collapse in main pane
      visible = get_visible_items
      return if @current >= visible.length

      item = visible[@current]
      real_idx = get_real_index(item)

      if real_idx && has_children?(real_idx, @items) && !@items[real_idx]["fold"]
        @items[real_idx]["fold"] = true
        record_last_action(:toggle_fold, nil)
      end
    end
  end

  def uncollapse_item
    if @split_view && @active_pane == :split
      # Handle uncollapse in split pane
      visible_items = get_visible_split_items
      return if @split_current >= visible_items.length

      item = visible_items[@split_current]
      real_idx = @split_items.index(item)

      if real_idx && has_children_in_array?(real_idx, @split_items) && item["fold"]
        item["fold"] = false
      end
    else
      # Handle uncollapse in main pane
      visible = get_visible_items
      return if @current >= visible.length

      item = visible[@current]
      real_idx = get_real_index(item)

      if real_idx && has_children?(real_idx, @items) && @items[real_idx]["fold"]
        @items[real_idx]["fold"] = false
        record_last_action(:toggle_fold, nil)
      end
    end
  end

  def move_up
    if @presentation_mode
      # In presentation mode, we need to handle navigation differently
      visible_before = get_visible_items
      
      if @current == 0
        # Wrap around to last item
        target_index = visible_before.length - 1
      else
        target_index = @current - 1
      end
      
      # Get the actual item we want to move to
      target_item = visible_before[target_index]
      target_real_idx = get_real_index(target_item)
      
      # Update presentation focus for the target item
      @current = target_index
      update_presentation_focus
      
      # Now find where the target item ended up after reorganization
      visible_after = get_visible_items
      visible_after.each_with_index do |item, idx|
        if get_real_index(item) == target_real_idx
          @current = idx
          break
        end
      end
    else
      # Normal mode navigation
      max_items = get_visible_items.length - 1
      
      if @current == 0
        # Wrap around to last item
        @current = max_items
      else
        @current = [@current - 1, 0].max
      end
    end
  end
  
  def move_down
    if @presentation_mode
      # In presentation mode, we need to handle navigation differently
      visible_before = get_visible_items
      max = visible_before.length - 1
      
      if @current == max
        # Wrap around to first item
        target_index = 0
      else
        target_index = @current + 1
      end
      
      # Get the actual item we want to move to
      target_item = visible_before[target_index]
      target_real_idx = get_real_index(target_item)
      
      # Update presentation focus for the target item
      @current = target_index
      update_presentation_focus
      
      # Now find where the target item ended up after reorganization
      visible_after = get_visible_items
      visible_after.each_with_index do |item, idx|
        if get_real_index(item) == target_real_idx
          @current = idx
          break
        end
      end
    else
      # Normal mode navigation
      max = get_visible_items.length - 1
      
      if @current == max
        # Wrap around to first item
        @current = 0
      else
        @current = [@current + 1, max].min
      end
    end
  end
  
  def page_up
    if @split_view && @active_pane == :split
      @split_current = [@split_current - (@split_pane.h - 1), 0].max
    elsif @presentation_mode
      # In presentation mode, handle page navigation differently
      visible_before = get_visible_items
      target_index = [@current - (@main.h - 1), 0].max
      
      if target_index < visible_before.length
        target_item = visible_before[target_index]
        target_real_idx = get_real_index(target_item)
        
        @current = target_index
        update_presentation_focus
        
        # Find where the target item ended up
        visible_after = get_visible_items
        visible_after.each_with_index do |item, idx|
          if get_real_index(item) == target_real_idx
            @current = idx
            break
          end
        end
      end
      @offset = [@offset - (@main.h - 1), 0].max
    else
      @current = [@current - (@main.h - 1), 0].max
      @offset = [@offset - (@main.h - 1), 0].max
    end
  end
  
  def page_down
    if @split_view && @active_pane == :split
      max = get_visible_split_items.length - 1
      @split_current = [@split_current + (@split_pane.h - 1), max].min
    elsif @presentation_mode
      # In presentation mode, handle page navigation differently  
      visible_before = get_visible_items
      max = visible_before.length - 1
      target_index = [@current + (@main.h - 1), max].min
      
      target_item = visible_before[target_index]
      target_real_idx = get_real_index(target_item)
      
      @current = target_index
      update_presentation_focus
      
      # Find where the target item ended up
      visible_after = get_visible_items
      visible_after.each_with_index do |item, idx|
        if get_real_index(item) == target_real_idx
          @current = idx
          break
        end
      end
    else
      max = get_visible_items.length - 1
      @current = [@current + (@main.h - 1), max].min
    end
  end
  
  def go_to_parent
    visible = get_visible_items
    return if @current >= visible.length
    
    current_level = visible[@current]["level"]
    return if current_level == 0
    
    if @presentation_mode
      # Find parent and navigate to it properly
      target_idx = nil
      (@current - 1).downto(0) do |i|
        if visible[i]["level"] < current_level
          target_idx = i
          break
        end
      end
      
      if target_idx
        target_item = visible[target_idx]
        target_real_idx = get_real_index(target_item)
        
        @current = target_idx
        update_presentation_focus
        
        # Find where the target item ended up
        visible_after = get_visible_items
        visible_after.each_with_index do |item, idx|
          if get_real_index(item) == target_real_idx
            @current = idx
            break
          end
        end
      end
    else
      # Search upward for parent
      (@current - 1).downto(0) do |i|
        if visible[i]["level"] < current_level
          @current = i
          break
        end
      end
    end
  end
  
  def go_to_first_child
    visible = get_visible_items
    return if @current >= visible.length - 1
    
    current_level = visible[@current]["level"]
    if visible[@current + 1]["level"] > current_level
      if @presentation_mode
        target_item = visible[@current + 1]
        target_real_idx = get_real_index(target_item)
        
        @current += 1
        update_presentation_focus
        
        # Find where the target item ended up
        visible_after = get_visible_items
        visible_after.each_with_index do |item, idx|
          if get_real_index(item) == target_real_idx
            @current = idx
            break
          end
        end
      else
        @current += 1
      end
    end
  end
  
  def jump_to_next_sibling
    visible = get_visible_items
    return if @current >= visible.length - 1
    
    current_level = visible[@current]["level"]
    
    # Search forward for the next item at the same level
    (@current + 1...visible.length).each do |i|
      if visible[i]["level"] == current_level
        @current = i
        update_presentation_focus if @presentation_mode
        return
      elsif visible[i]["level"] < current_level
        # We've gone up a level, no more siblings
        return
      end
    end
  end
  
  def jump_to_prev_sibling
    visible = get_visible_items
    return if @current <= 0
    
    current_level = visible[@current]["level"]
    
    # Search backward for the previous item at the same level
    (@current - 1).downto(0) do |i|
      if visible[i]["level"] == current_level
        @current = i
        update_presentation_focus if @presentation_mode
        return
      elsif visible[i]["level"] < current_level
        # We've gone up a level, no more siblings before this
        return
      end
    end
  end
  
  def expand_to_level(level)
    @items.each do |item|
      item["fold"] = item["level"] >= level
    end
  end
  
  def jump_to_next_template_marker
    visible_items = get_visible_items
    return if visible_items.empty?
    
    start_idx = @current
    
    # Search forward from current position
    ((start_idx + 1)...visible_items.length).each do |idx|
      if visible_items[idx]["text"].include?("=")
        @current = idx
        render  # Show the highlighted item first
        edit_line  # Then edit it
        return
      end
    end
    
    # Wrap around to beginning
    (0..start_idx).each do |idx|
      if visible_items[idx]["text"].include?("=")
        @current = idx
        render  # Show the highlighted item first
        edit_line  # Then edit it
        return
      end
    end
    
    @message = "No template markers found"
  end
  
  def toggle_presentation_mode
    if @presentation_mode
      # Exit presentation mode - restore normal view
      @presentation_mode = false
      # Clear all presentation focus flags and unfold everything
      @items.each do |item| 
        item["presentation_focus"] = false
        item["fold"] = false  # Unfold everything when exiting presentation mode
      end
      # Clear cache to force re-rendering
      @processed_cache.clear
      @message = "Presentation mode disabled"
    else
      # Enter presentation mode
      # Remember which item we're on before any folding changes
      visible_items = get_visible_items
      if @current < visible_items.length
        target_item = visible_items[@current]
      end
      
      @presentation_mode = true
      # Clear cache to force re-rendering  
      @processed_cache.clear
      update_presentation_focus
      
      # Make sure cursor is still on the same item after initial folding
      if target_item
        new_visible = get_visible_items
        new_position = new_visible.index(target_item)
        @current = new_position if new_position
      end
      
      @message = "Presentation mode enabled - focus on current item"
    end
  end
  
  def update_presentation_focus
    # This method updates the focus in presentation mode
    # It will be called whenever the cursor moves
    return unless @presentation_mode
    
    visible_items = get_visible_items
    return if visible_items.empty? || @current >= visible_items.length
    
    # Remember which item we're focused on
    current_item = visible_items[@current]
    current_level = current_item["level"]
    current_real_idx = get_real_index(current_item)
    
    # First, fold everything
    @items.each_with_index do |item, idx|
      item["fold"] = has_children?(idx, @items)
      item["presentation_focus"] = false
    end
    
    # Mark current item as in focus and unfold it in the main items array
    if current_real_idx && current_real_idx < @items.length
      @items[current_real_idx]["presentation_focus"] = true
      @items[current_real_idx]["fold"] = false
    end
    
    # Unfold all ancestors of current item
    ancestor_indices = []
    search_level = current_level - 1
    idx = current_real_idx - 1
    
    while idx >= 0 && search_level >= 0
      if @items[idx]["level"] == search_level
        @items[idx]["fold"] = false
        @items[idx]["presentation_focus"] = false  # Ancestors visible but not focused
        ancestor_indices << idx
        search_level -= 1
      end
      idx -= 1
    end
    
    # Mark immediate children as in focus (only one level down)
    idx = current_real_idx + 1
    while idx < @items.length && @items[idx]["level"] > current_level
      if @items[idx]["level"] == current_level + 1
        @items[idx]["presentation_focus"] = true
        # Don't unfold children - let them stay folded unless user explicitly unfolds
      end
      idx += 1
    end
    
    # Now recalculate the cursor position to point to the same item
    new_visible_items = get_visible_items
    new_position = new_visible_items.index(current_item)
    if new_position
      @current = new_position
    end
    
    # Clear cache to force re-rendering with new focus
    @processed_cache.clear
  end
  
  def is_item_in_presentation_focus?(item)
    return true unless @presentation_mode
    item["presentation_focus"] == true
  end
  
  def save_undo_state
    # Deep copy the CURRENT items array before modification
    state_copy = @items.map { |item| item.dup }
    
    # Add to undo stack
    @undo_stack << state_copy
    @undo_position << @current
    
    # Clear redo stack when new action is performed
    @redo_stack.clear
    @redo_position.clear
    
    # Limit undo stack to 100 levels to prevent memory issues
    if @undo_stack.length > 100
      @undo_stack.shift
      @undo_position.shift
    end
    
    # Debug output
    # @message = "Saved undo state (stack size: #{@undo_stack.length})"
  end
  
  def states_equal?(state1, state2)
    return false if state1.length != state2.length
    state1.each_with_index do |item, idx|
      return false if item["text"] != state2[idx]["text"] || 
                     item["level"] != state2[idx]["level"]
    end
    true
  end
  
  def clear_cache
    @processed_cache = {}
    @last_rendered_content = nil
  end
  
  def undo
    # Need at least one state to undo to
    if @undo_stack.empty?
      @message = "Nothing to undo"
      return
    end
    
    # Save current state to redo stack before changing
    current_state = @items.map { |item| item.dup }
    @redo_stack << current_state
    @redo_position << @current
    
    # Restore the previous state from undo stack
    previous_state = @undo_stack.pop
    previous_position = @undo_position.pop
    
    @items = previous_state.map { |item| item.dup }
    
    # Restore cursor position, but ensure it's valid
    visible = get_visible_items
    if previous_position && visible.length > 0
      @current = [previous_position, visible.length - 1].min
      @current = 0 if @current < 0
    else
      @current = 0
    end
    
    # Clear cache since items changed
    clear_cache
    
    @modified = true
    @message = "Undone (#{@undo_stack.length} undo levels, #{@redo_stack.length} redo available)"
  end
  
  def record_last_action(type, data = nil)
    @last_action_type = type
    @last_action = data
  end
  
  def repeat_last_action
    return unless @last_action_type
    
    case @last_action_type
    when :insert_line
      insert_line_with_text(@last_action)
    when :insert_child
      insert_child_with_text(@last_action)
    when :insert_outdented
      insert_outdented_with_text(@last_action)
    when :delete_line
      delete_line
    when :edit_line
      if @last_action && @last_action[:new_text]
        edit_current_line(@last_action[:new_text])
      end
    when :toggle_checkbox
      toggle_checkbox
    when :toggle_checkbox_with_date
      toggle_checkbox_with_date
    when :toggle_fold
      toggle_fold
    when :indent_right
      indent_right(@last_action || true)
    when :indent_left
      indent_left(@last_action || true)
    when :paste
      paste_line
    when :yank_line
      yank_line(@last_action || false)
    else
      @message = "No repeatable action"
    end
  end
  
  def redo_change  # Renamed to avoid conflict with Ruby's redo keyword
    # Need at least one state to redo
    if @redo_stack.empty?
      @message = "Nothing to redo"
      return
    end
    
    # Save current state back to undo stack
    current_state = @items.map { |item| item.dup }
    @undo_stack << current_state
    @undo_position << @current
    
    # Restore the state from redo stack
    redo_state = @redo_stack.pop
    redo_position = @redo_position.pop
    
    @items = redo_state.map { |item| item.dup }
    
    # Restore cursor position, but ensure it's valid
    visible = get_visible_items
    if redo_position && visible.length > 0
      @current = [redo_position, visible.length - 1].min
      @current = 0 if @current < 0
    else
      @current = 0
    end
    
    # Clear cache since items changed
    clear_cache
    
    @modified = true
    @message = "Redone (#{@undo_stack.length} undo levels, #{@redo_stack.length} redo available)"
  end
  
  def insert_line
    @mode = :insert
    
    input = @footer.ask("New item: ", "")
    
    if input && !input.strip.empty?
      insert_line_with_text(input)
      record_last_action(:insert_line, input)
    end
    
    @mode = :normal
    @footer.clear  # Clear footer immediately
    @footer.refresh
  end
  
  def insert_line_with_text(text)
    return unless text && !text.strip.empty?

    save_undo_state  # Save state before modification
    visible = get_visible_items
    if @current < visible.length
      level = visible[@current]["level"]
      real_idx = get_real_index(visible[@current])

      # If current item has collapsed children, insert after all descendants
      if @items[real_idx]["fold"] && has_children?(real_idx, @items)
        insert_idx = get_last_descendant_index(real_idx, @items)
      else
        insert_idx = real_idx + 1
      end

      @items.insert(insert_idx, {"text" => text, "level" => level, "fold" => false})
    else
      @items << {"text" => text, "level" => 0, "fold" => false}
    end
    @modified = true
    @current += 1
  end
  
  def insert_child
    @mode = :insert
    
    input = @footer.ask("New child item: ", "")
    
    if input && !input.strip.empty?
      insert_child_with_text(input)
      record_last_action(:insert_child, input)
    end
    
    @mode = :normal
    @footer.clear  # Clear footer immediately
    @footer.refresh
  end
  
  def insert_outdented
    @mode = :insert
    
    input = @footer.ask("New outdented item: ", "")
    
    if input && !input.strip.empty?
      insert_outdented_with_text(input)
      record_last_action(:insert_outdented, input)
    end
    
    @mode = :normal
    @footer.clear  # Clear footer immediately
    @footer.refresh
  end
  
  def insert_child_with_text(text)
    return unless text && !text.strip.empty?

    save_undo_state  # Save state before modification
    visible = get_visible_items
    if @current < visible.length
      level = visible[@current]["level"] + 1
      real_idx = get_real_index(visible[@current])

      # If current item has collapsed children, insert as last child
      if @items[real_idx]["fold"] && has_children?(real_idx, @items)
        # Insert just before the next sibling (at the end of all descendants)
        insert_idx = get_last_descendant_index(real_idx, @items)
      else
        # No collapsed children, insert right after current item
        insert_idx = real_idx + 1
      end

      # Unfold parent if needed
      @items[real_idx]["fold"] = false

      @items.insert(insert_idx, {"text" => text, "level" => level, "fold" => false})
    else
      @items << {"text" => text, "level" => 1, "fold" => false}
    end
    @modified = true
    @current += 1
  end
  
  def insert_outdented_with_text(text)
    return unless text && !text.strip.empty?
    
    save_undo_state  # Save state before modification
    visible = get_visible_items
    if @current < visible.length
      current_level = visible[@current]["level"]
      # Outdent means one level less, but not less than 0
      level = [current_level - 1, 0].max
      real_idx = get_real_index(visible[@current])
      
      # Find where to insert: after current item and all its descendants
      insert_idx = real_idx + 1
      while insert_idx < @items.length && @items[insert_idx]["level"] > current_level
        insert_idx += 1
      end
      
      @items.insert(insert_idx, {"text" => text, "level" => level, "fold" => false})
      
      # Update cursor to point to the new item
      @current = get_visible_items.index { |item| item.equal?(@items[insert_idx]) } || (@current + 1)
    else
      # If at end of list, add at level 0
      @items << {"text" => text, "level" => 0, "fold" => false}
      @current = get_visible_items.length - 1
    end
    @modified = true
  end
  
  def edit_line
    visible = get_visible_items
    return if @current >= visible.length
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    @mode = :insert
    
    input = @footer.ask("Edit: ", item["text"])
    
    if input && input != item["text"]
      edit_current_line(input)
      record_last_action(:edit_line, {old_text: item["text"], new_text: input})
    end
    
    @mode = :normal
    @footer.clear  # Clear footer immediately
    @footer.refresh
  end
  
  def edit_current_line(text)
    visible = get_visible_items
    return if @current >= visible.length
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    save_undo_state  # Save state before modification
    @items[real_idx]["text"] = text
    @modified = true
    clear_cache  # Clear cache when content changes
  end
  
  def uppercase_line
    visible = get_visible_items
    return if @current >= visible.length
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    save_undo_state  # Save state before modification
    @items[real_idx]["text"] = item["text"].upcase
    @modified = true
    clear_cache  # Clear cache when content changes
    @message = "Line converted to uppercase"
  end
  
  def lowercase_line
    visible = get_visible_items
    return if @current >= visible.length
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    save_undo_state  # Save state before modification
    @items[real_idx]["text"] = item["text"].downcase
    @modified = true
    clear_cache  # Clear cache when content changes
    @message = "Line converted to lowercase"
  end
  
  def delete_line(with_children = false)
    visible = get_visible_items
    return if visible.empty?
    return if @current >= visible.length
    
    save_undo_state  # Save state before modification
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    # First, yank the item(s) to clipboard
    @clipboard = []
    @clipboard << item.dup
    
    # Determine what to delete
    level = item["level"]
    delete_count = 1
    
    if with_children
      # Delete item and its children (C-D was used)
      @clipboard_is_tree = true  # Mark as tree for paste behavior
      ((real_idx + 1)...@items.length).each do |i|
        if @items[i]["level"] > level
          @clipboard << @items[i].dup  # Also add children to clipboard
          delete_count += 1
        else
          break
        end
      end
    else
      # For single line delete (D key - delete only the current line)
      @clipboard_is_tree = false  # Mark as single/adaptive for paste behavior
      # Don't include children - delete_count stays at 1
    end
    
    # Delete the items
    # Remember the level of the deleted item for renumbering
    deleted_level = item["level"]
    
    delete_count.times { @items.delete_at(real_idx) }
    
    @items = [{"text" => "Empty", "level" => 0, "fold" => false}] if @items.empty?
    
    # Renumber siblings at the deleted item's level
    renumber_siblings(deleted_level) unless @items.length == 1
    
    @current = [@current, get_visible_items.length - 1].min
    @current = 0 if @current < 0
    @modified = true
    
    # Show message
    @message = "Deleted and yanked #{@clipboard.length} item(s)"
    
    record_last_action(:delete_line, with_children)
  end
  
  def yank_line(with_children = false)
    visible = get_visible_items
    return if @current >= visible.length
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    @clipboard = []
    @clipboard << item.dup
    @clipboard_is_tree = with_children  # Remember if this is a tree copy (Y) or single (y)
    
    # Copy children if requested
    if with_children
      level = item["level"]
      ((real_idx + 1)...@items.length).each do |i|
        if @items[i]["level"] > level
          @clipboard << @items[i].dup
        else
          break
        end
      end
    end
    
    @message = "Yanked #{@clipboard.length} item(s)"
    record_last_action(:yank_line, with_children)
  end
  
  def paste_line
    return unless @clipboard && !@clipboard.empty?
    
    save_undo_state  # Save state before modification
    
    visible = get_visible_items
    if @current < visible.length
      real_idx = get_real_index(visible[@current])
      
      if @clipboard_is_tree
        # For tree paste (C-D or Y), maintain original indentation structure
        # Just insert after current position without adjusting levels
        @clipboard.reverse.each do |item|
          new_item = item.dup
          @items.insert(real_idx + 1, new_item)
        end
      else
        # For single/adaptive paste (D or y), adjust to match context
        base_level = visible[@current]["level"]
        level_diff = base_level - @clipboard[0]["level"]
        
        @clipboard.reverse.each do |item|
          new_item = item.dup
          new_item["level"] = item["level"] + level_diff
          @items.insert(real_idx + 1, new_item)
        end
      end
    else
      # Pasting at end of list - maintain original levels
      @clipboard.each do |item|
        @items << item.dup
      end
    end
    
    @modified = true
    @message = "Pasted #{@clipboard.length} item(s)"
    record_last_action(:paste, nil)
  end

  def calculate_level_for_position(target_real_idx)
    # Calculate appropriate level for an item at target_real_idx position
    # based on surrounding items in the @items array

    # If at the beginning, level 0
    return 0 if target_real_idx == 0

    # Look at the previous item
    prev_item = @items[target_real_idx - 1]
    prev_level = prev_item["level"]

    # Look at the next item if it exists
    if target_real_idx < @items.length
      next_item = @items[target_real_idx]
      next_level = next_item["level"]

      # If next item is at same or lower level than previous,
      # we can be at the same level as previous (sibling)
      if next_level <= prev_level
        return prev_level
      else
        # Next item is deeper, so we could be parent (prev_level)
        # or child (prev_level + 1), choose to be sibling of previous
        return prev_level
      end
    else
      # At the end, can be sibling of previous item
      return prev_level
    end
  end

  def find_orphaned_children(item_text, target_real_idx)
    # Look for children that might belong to the item being moved
    orphaned_children = []

    # Search from target position onwards for potential children
    # Look for items at level 2 or higher that could be children
    (target_real_idx...@items.length).each do |i|
      item_level = @items[i]["level"]

      # Stop if we hit an item at level 0 or 1 (new parent/sibling)
      break if item_level <= 1

      # If we find items at level 2+, they could be orphaned children
      # (In the example: Subtask A1.1, A1.2 are level 2)
      if item_level >= 2
        orphaned_children << i
      else
        break  # Hit a sibling, stop looking
      end
    end

    orphaned_children
  end

  def ensure_destination_visible(target_real_idx, item_level)
    # Unfold any collapsed areas that would hide an item at target_real_idx with item_level
    return if target_real_idx >= @items.length || target_real_idx < 0

    # Walk backwards from the target position to find potential ancestor items
    (target_real_idx - 1).downto(0) do |i|
      item = @items[i]

      # If this item is at a higher level (lower number) than our item will be, it's a potential ancestor
      if item["level"] < item_level
        # If this ancestor is folded, unfold it to make the destination visible
        if item["fold"] && has_children?(i, @items)
          item["fold"] = false
        end

        # Update item_level to continue searching for higher ancestors
        item_level = item["level"]

        # If we reach level 0, we're done
        break if item_level == 0
      end
    end
  end

  def force_item_visible(target_real_idx)
    # Absolutely ensure the item at target_real_idx is visible - last resort safety net
    return if target_real_idx >= @items.length || target_real_idx < 0

    target_item = @items[target_real_idx]
    target_level = target_item["level"]

    # Walk backwards and unfold ALL ancestors, no matter what
    (target_real_idx - 1).downto(0) do |i|
      item = @items[i]

      # If this item could be an ancestor (higher in hierarchy)
      if item["level"] < target_level
        # Force unfold it, regardless of whether it has children
        item["fold"] = false if item.has_key?("fold")

        # Update target_level to continue searching
        target_level = item["level"]

        # Continue until we reach level 0
        break if target_level == 0
      end
    end

    # Force a cache clear to ensure visibility updates
    clear_cache if respond_to?(:clear_cache)
  end

  def move_item_up(with_children = false)
    visible = get_visible_items
    return if @current >= visible.length || @current == 0

    save_undo_state  # Save state before modification

    current_item = visible[@current]
    current_real_idx = get_real_index(current_item)

    # Get the previous visible item
    prev_visible_item = visible[@current - 1]
    prev_real_idx = get_real_index(prev_visible_item)

    # Collect items to move (current item + children if requested)
    items_to_move = [current_item]
    if with_children
      level = current_item["level"]
      ((current_real_idx + 1)...@items.length).each do |i|
        if @items[i]["level"] > level
          items_to_move << @items[i]
        else
          break
        end
      end
    end

    # Calculate what level the moved item should have at the target position
    new_level = calculate_level_for_position(prev_real_idx)
    level_diff = new_level - items_to_move.first["level"]

    # Unfold destination area BEFORE moving if needed
    ensure_destination_visible(prev_real_idx, new_level)

    # Remove the items to move
    items_to_move.length.times { @items.delete_at(current_real_idx) }

    # Adjust target position since we removed items after it
    adjusted_target = prev_real_idx
    if prev_real_idx > current_real_idx
      adjusted_target -= items_to_move.length
    end

    # Adjust levels of moved items
    items_to_move.each do |moved_item|
      moved_item["level"] += level_diff
      moved_item["level"] = [moved_item["level"], 0].max  # Ensure level doesn't go negative
    end

    # Insert items at target position
    items_to_move.each_with_index do |item_to_move, idx|
      @items.insert(adjusted_target + idx, item_to_move)
    end

    # FORCE the moved item to be visible (safety net)
    force_item_visible(adjusted_target)

    # Update cursor to follow the moved item
    new_visible = get_visible_items
    new_item_idx = new_visible.find_index { |v| get_real_index(v) == adjusted_target }
    @current = new_item_idx if new_item_idx

    @modified = true
    @message = "Moved #{items_to_move.length} item(s) up"
    record_last_action(:move_item_up, with_children)
  end
  
  def move_item_down(with_children = false)
    visible = get_visible_items
    return if @current >= visible.length - 1

    save_undo_state  # Save state before modification

    current_item = visible[@current]
    current_real_idx = get_real_index(current_item)

    # Get the next visible item
    next_visible_item = visible[@current + 1]
    next_real_idx = get_real_index(next_visible_item)

    # Collect items to move (current item + children if requested)
    items_to_move = [current_item]
    if with_children
      level = current_item["level"]
      ((current_real_idx + 1)...@items.length).each do |i|
        if @items[i]["level"] > level
          items_to_move << @items[i]
        else
          break
        end
      end
    end

    # Target is immediately after the next visible item (not after its children)
    target_real_idx = next_real_idx + 1

    # Check if there are orphaned children at the target position
    # If so, position before them to reunite
    orphaned_children = find_orphaned_children(current_item["text"], target_real_idx)
    if !orphaned_children.empty?
      target_real_idx = orphaned_children.first
    end

    # Calculate what level the moved item should have at the target position
    new_level = calculate_level_for_position(target_real_idx)
    level_diff = new_level - items_to_move.first["level"]

    # Unfold destination area BEFORE moving if needed
    ensure_destination_visible(target_real_idx, new_level)

    # Remove the items to move
    items_to_move.length.times { @items.delete_at(current_real_idx) }

    # Adjust target position since we removed items before it
    adjusted_target = target_real_idx - items_to_move.length

    # Adjust levels of moved items
    items_to_move.each do |moved_item|
      moved_item["level"] += level_diff
      moved_item["level"] = [moved_item["level"], 0].max  # Ensure level doesn't go negative
    end

    # Insert items at target position
    items_to_move.each_with_index do |item_to_move, idx|
      @items.insert(adjusted_target + idx, item_to_move)
    end

    # FORCE the moved item to be visible (safety net)
    force_item_visible(adjusted_target)

    # Update cursor to follow the moved item
    new_visible = get_visible_items
    new_item_idx = new_visible.find_index { |v| get_real_index(v) == adjusted_target }
    @current = new_item_idx if new_item_idx

    @modified = true
    @message = "Moved #{items_to_move.length} item(s) down"
    record_last_action(:move_item_down, with_children)
  end
  
  def renumber_siblings(changed_level)
    # Renumber items at the specified level that start with numbers
    current_number = 1
    @items.each do |item|
      if item["level"] == changed_level
        # Check if item starts with a number pattern like "1." or "1)"
        if item["text"] =~ /^\d+[\.\)]\s+(.+)/
          # Replace the number with the current sequential number
          item["text"] = "#{current_number}. #{$1}"
          current_number += 1
        end
      end
    end
  end
  
  def indent_right(with_children = true)
    visible = get_visible_items
    return if @current >= visible.length
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    # Can only indent if there's a previous item at same or higher level
    if real_idx > 0
      save_undo_state  # Save state before modification
      original_level = @items[real_idx]["level"]
      @items[real_idx]["level"] += 1
      
      # Also indent children if requested
      if with_children
        ((real_idx + 1)...@items.length).each do |i|
          if @items[i]["level"] > original_level
            @items[i]["level"] += 1
          else
            break
          end
        end
      end
      
      @modified = true
      record_last_action(:indent_right, with_children)
    end
  end
  
  def indent_left(with_children = true)
    visible = get_visible_items
    return if @current >= visible.length
    
    item = visible[@current]
    real_idx = get_real_index(item)
    
    if @items[real_idx]["level"] > 0
      save_undo_state  # Save state before modification
      original_level = @items[real_idx]["level"]
      @items[real_idx]["level"] -= 1
      
      # Also unindent children if requested
      if with_children
        ((real_idx + 1)...@items.length).each do |i|
          if @items[i]["level"] > original_level
            @items[i]["level"] -= 1
          else
            break
          end
        end
      end
      
      @modified = true
      record_last_action(:indent_left, with_children)
    end
  end
  
  def toggle_checkbox
    visible = get_visible_items
    return if @current >= visible.length
    
    save_undo_state  # Save state before modification
    
    item = visible[@current]
    real_idx = get_real_index(item)
    text = @items[real_idx]["text"]
    
    if text =~ /^\[.\]/
      # Cycle through states: [ ]/[_] -> [X] -> [O] -> [-] -> [ ]
      text = case text[1]
      when ' ', '_' then text.sub(/^\[[ _]\]/, '[X]')
      when 'X', 'x' then text.sub(/^\[[Xx]\]/, '[O]')
      when 'O' then text.sub(/^\[O\]/, '[-]')
      when '-' then text.sub(/^\[-\]/, '[ ]')
      else text
      end
    else
      # Add checkbox
      text = "[ ] #{text}"
    end
    
    @items[real_idx]["text"] = text
    @modified = true
    record_last_action(:toggle_checkbox, nil)
  end
  
  def toggle_checkbox_with_date
    visible = get_visible_items
    return if @current >= visible.length
    
    save_undo_state  # Save state before modification
    
    item = visible[@current]
    real_idx = get_real_index(item)
    text = @items[real_idx]["text"]
    
    # First, handle existing timestamp in the hyperlist.vim format
    # Format is: [x] YYYY-MM-DD HH.MM: rest of text
    text = text.sub(/ \d{4}-\d{2}-\d{2} \d{2}\.\d{2}:/, '')
    
    if text =~ /^\[.\]/
      # Toggle checkbox states with date stamping
      text = case text[1]
      when ' '
        # Unchecked -> mark as in progress
        text.sub(/^\[ \]/, '[_]')
      when '_'
        # In progress -> mark as completed with timestamp
        time = Time.now.strftime("%Y-%m-%d %H.%M")
        text.sub(/^\[_\]/, "[x] #{time}:")
      when 'x', 'X'
        # Completed -> back to unchecked
        text.sub(/^\[[xX]\]/, '[_]')
      when 'O'
        # In progress (capital O) -> completed with timestamp
        time = Time.now.strftime("%Y-%m-%d %H.%M")
        text.sub(/^\[O\]/, "[x] #{time}:")
      else text
      end
    else
      # Add checkbox in unchecked state
      text = "[_] #{text}"
    end
    
    @items[real_idx]["text"] = text
    @modified = true
    record_last_action(:toggle_checkbox_with_date, nil)
  end
  
  def search_forward
    @mode = :search
    @search = @footer.ask("Search: ", @search || "")
    @mode = :normal
    @footer.clear  # Clear footer immediately
    @footer.refresh
    
    return if !@search || @search.empty?
    
    # Find all matches for highlighting
    find_all_matches
    
    visible = get_visible_items
    start = (@current + 1) % visible.length
    
    visible.length.times do |i|
      idx = (start + i) % visible.length
      if visible[idx]["text"].downcase.include?(@search.downcase)
        @current = idx
        @message = "Found: #{@search} (#{@search_matches.length} total matches)"
        clear_cache  # Clear cache to show highlighting
        return
      end
    end
    
    @message = "Not found: #{@search}"
    @search_matches = []
  end
  
  def find_all_matches
    @search_matches = []
    return if !@search || @search.empty?
    
    get_visible_items.each_with_index do |item, idx|
      if item["text"].downcase.include?(@search.downcase)
        @search_matches << idx
      end
    end
  end
  
  def search_next
    return if !@search || @search.empty?
    
    visible = get_visible_items
    start = (@current + 1) % visible.length
    
    visible.length.times do |i|
      idx = (start + i) % visible.length
      if visible[idx]["text"].downcase.include?(@search.downcase)
        @current = idx
        return
      end
    end
    
    @message = "No more matches"
  end
  
  def help_line(cmd1, desc1, cmd2 = nil, desc2 = nil)
    # Format help lines with consistent column spacing
    # Start with no leading space
    line = ""
    
    # First command and description
    line += cmd1
    # Calculate real length without ANSI codes
    cmd1_real_length = cmd1.gsub(/\e\[[0-9;]*m/, '').length
    # Longest commands are like ":recent :r" (10 chars), "C-DOWN" (6 chars)
    max_cmd_length = 11
    spaces_needed = max_cmd_length - cmd1_real_length
    line += " " * [spaces_needed, 1].max  # At least 1 space after command
    
    # Add first description - don't truncate
    line += desc1
    
    # Second command and description (if provided)
    if cmd2 && desc2
      # Calculate position for second column
      # Need to account for ANSI codes in desc1
      desc1_real_length = desc1.gsub(/\e\[[0-9;]*m/, '').length
      current_pos = cmd1_real_length + spaces_needed + desc1_real_length
      
      # Start second column at position 40
      target_pos = 40
      padding_needed = target_pos - current_pos
      line += " " * [padding_needed, 3].max  # At least 3 spaces between columns
      
      line += cmd2
      cmd2_real_length = cmd2.gsub(/\e\[[0-9;]*m/, '').length
      # Align second column descriptions (longest is ":export :ex" = 11 chars, ":vsplit :vs" = 11 chars)
      max_cmd2_length = 13  # 11 chars max + 2 spaces minimum padding
      spaces_needed2 = max_cmd2_length - cmd2_real_length
      line += " " * spaces_needed2
      line += desc2
    end
    
    line
  end
  
  def show_help
    # Build help text using consistent formatting
    help_lines = []
    help_lines << " Press #{"?".fg("10")} for full documentation, #{"UP/DOWN".fg("10")} to scroll, or any other key to return"
    help_lines << ""
    help_lines << "#{"HYPERLIST KEY BINDINGS".b}"
    help_lines << ""
    help_lines << "#{"NAVIGATION".fg("14")}"
    help_lines << help_line("#{"j/↓".fg("10")}", "Move down", "#{"k/↑".fg("10")}", "Move up")
    help_lines << help_line("#{"h".fg("10")}", "Go to parent", "#{"l".fg("10")}", "Go to first child")
    help_lines << help_line("#{"PgUp".fg("10")}", "Page up", "#{"PgDn".fg("10")}", "Page down")
    help_lines << help_line("#{"g/Home".fg("10")}", "Go to top", "#{"G/End".fg("10")}", "Go to bottom")
    help_lines << help_line("#{"R".fg("10")}", "Jump to reference", "#{"F".fg("10")}", "Open file/URL")
    help_lines << help_line("#{"ma".fg("10")}", "Set mark 'a'", "#{"'a".fg("10")}", "Jump to mark 'a'")
    help_lines << help_line("#{"''".fg("10")}", "Jump to prev position", "#{"N".fg("10")}", "Next = template marker")
    help_lines << ""
    help_lines << "#{"SEARCH".fg("14")}"
    help_lines << help_line("#{"/".fg("10")}", "Search forward", "#{"n".fg("10")}", "Next match")
    help_lines << ""
    help_lines << "#{"FOLDING".fg("14")}"
    help_lines << help_line("#{"Space".fg("10")}", "Toggle fold", "#{"za".fg("10")}", "Toggle all folds")
    help_lines << help_line("#{"zo".fg("10")}", "Open fold", "#{"zc".fg("10")}", "Close fold")
    help_lines << help_line("#{"zR".fg("10")}", "Open all", "#{"zM".fg("10")}", "Close all")
    help_lines << help_line("#{"1-9".fg("10")}", "Expand to level", "#{"0".fg("10")}", "Multi-digit fold level")
    help_lines << help_line("#{"▶".fg("245")}", "Collapsed (hidden)")
    help_lines << help_line("#{"▷".fg("245")}", "Expanded (visible)")
    help_lines << ""
    help_lines << "#{"EDITING".fg("14")}"
    help_lines << help_line("#{"i/Enter".fg("10")}", "Edit line", "#{"o".fg("10")}", "Insert line below")
    help_lines << help_line("#{"O".fg("10")}", "Insert line above", "#{"a".fg("10")}", "Insert child")
    help_lines << help_line("#{"A".fg("10")}", "Insert outdented", "#{"W".fg("10")}", "Save and quit")
    help_lines << help_line("#{"gU".fg("10")}", "Uppercase line", "#{"gu".fg("10")}", "Lowercase line")
    help_lines << help_line("#{"I".fg("10")}", "Cycle indent (2-5)")
    help_lines << help_line("#{"D".fg("10")}", "Delete+yank line", "#{"C-D".fg("10")}", "Delete+yank item&descendants")
    help_lines << help_line("#{"y".fg("10")}" + "/".fg("10") + "#{"Y".fg("10")}", "Copy line/tree", "#{"p".fg("10")}", "Paste")
    help_lines << help_line("#{"u".fg("10")}", "Undo", "#{".".fg("10")}", "Repeat last action")
    help_lines << help_line("#{"r".fg("10")}" + ", ".fg("10") + "#{"C-R".fg("10")}", "Redo")
    help_lines << help_line("#{"S-UP".fg("10")}", "Move item up", "#{"S-DOWN".fg("10")}", "Move item down")
    help_lines << help_line("#{"C-UP".fg("10")}", "Move up in visible list", "#{"C-DOWN".fg("10")}", "Move down in visible list")
    help_lines << help_line("#{"→".fg("10")}", "Uncollapse item", "#{"←".fg("10")}", "Collapse item")
    help_lines << help_line("#{"Tab".fg("10")}", "Indent item+kids", "#{"S-Tab".fg("10")}", "Unindent item+kids")
    help_lines << ""
    help_lines << "#{"SPECIAL FEATURES".fg("14")}"
    help_lines << help_line("#{"v".fg("10")}", "Toggle checkbox", "#{"V".fg("10")}", "Checkbox with date")
    help_lines << help_line("#{"C-E".fg("10")}", "Encrypt/decrypt line", "#{"C-U".fg("10")}", "Toggle State/Trans underline")
    help_lines << help_line("#{"P".fg("10")}", "Presentation mode", "#{"Tab/S-Tab".fg("10")}", "Next/prev sibling (in P)")
    help_lines << help_line("#{"Ma".fg("10")}", "Record macro 'a'", "#{"@a".fg("10")}", "Play macro 'a'")
    help_lines << help_line("#{"w".fg("10")}", "Switch panes (split view)")
    help_lines << ""
    help_lines << "#{"FILE OPERATIONS".fg("14")}"
    help_lines << help_line("#{":w".fg("10")}", "Save", "#{":q".fg("10")}", "Quit")
    help_lines << help_line("#{":wq".fg("10")}", "Save and quit", "#{":e file".fg("10")}", "Open file")
    help_lines << help_line("#{":recent".fg("10")}", "Recent files", "#{":export :ex".fg("10")}", "Export md|html|txt")
    help_lines << help_line("#{":graph :g".fg("10")}", "Export to PNG graph", "#{":vsplit :vs".fg("10")}", "Split view")
    help_lines << help_line("#{":as on".fg("10")}", "Enable autosave", "#{":as off".fg("10")}", "Disable autosave")
    help_lines << help_line("#{":as N".fg("10")}", "Set interval (secs)", "#{":as".fg("10")}", "Show autosave status")
    help_lines << ""
    help_lines << "#{"TEMPLATES".fg("14")}"
    help_lines << help_line("#{"t".fg("10")}", "Insert template", "#{":st".fg("10")}", "Save as template")
    help_lines << help_line("#{":dt".fg("10")}", "Delete template", "#{":lt".fg("10")}", "List user templates")
    help_lines << ""
    
    help_lines << "#{"CONFIGURATION".fg("14")}"
    help_lines << help_line("#{":set".fg("10")}", "Show all settings")
    help_lines << help_line("#{":set o".fg("10")}", "Show option value")  
    help_lines << help_line("#{":set o=val".fg("10")}", "Set option value")
    help_lines << help_line("#{"Options:".fg("245")}", "theme, wrap, fold_level")
    help_lines << help_line("#{"".fg("245")}", "show_numbers, tab_width")
    help_lines << ""
    
    help_lines << "#{"HELP & QUIT".fg("14")}"
    help_lines << help_line("#{"?".fg("10")}", "This help", "#{"??".fg("10")}", "Full documentation")
    help_lines << help_line("#{"q".fg("10")}", "Quit (asks to save)", "#{"Q".fg("10")}", "Force quit")
    help_lines << ""
    help_lines << "#{"COLOR SCHEME".fg("14")}"
    help_lines << help_line("#{"[X]".fg("10")}", "Completed", "#{"[O]".fg("10").b}", "In progress")
    help_lines << help_line("#{"[ ]".fg("22")}", "Unchecked", "#{"[-]".fg("2")}", "Partial")
    help_lines << help_line("#{"[?]".fg("2")}", "Conditionals", "#{"AND:".fg("4")}", "Operators")
    help_lines << help_line("#{"Date:".fg("1")}", "Properties", "#{"<ref>".fg("5")}", "References")
    help_lines << help_line("#{"(comment)".fg("6")}", "Comments", "#{'"text"'.fg("14")}", "Quoted strings")
    help_lines << help_line("#{";".fg("2")}", "Separator", "#{"#tag".fg("184")}", "Hash tags")
    
    help = help_lines.join("\n")
    
    # Store current state
    saved_items = @items.dup
    saved_current = @current
    saved_offset = @offset
    saved_modified = @modified
    
    # Create temporary help items for scrolling
    @items = help.split("\n").map { |line| {"text" => line, "level" => 0, "fold" => false, "raw" => true} }
    @current = 0
    @offset = 0
    @modified = false
    
    # Help viewer loop
    loop do
      render_main
      @footer.text = "Help | UP/DOWN: scroll | ?: documentation | any other key: return"
      @footer.refresh
      
      c = getchr
      case c
      when "?"
        # Restore state before showing documentation
        @items = saved_items
        @current = saved_current
        @offset = saved_offset
        @modified = saved_modified
        show_documentation
        return
      when "j", "DOWN"
        move_down
      when "k", "UP"
        move_up
      when "PgUP"
        page_up
      when "PgDOWN"
        page_down
      when "HOME"
        @current = 0
        @offset = 0
      when "END"
        visible = get_visible_items
        @current = [visible.length - 1, 0].max
      else
        # Any other key returns to main view
        break
      end
    end
    
    # Restore original state
    @items = saved_items
    @current = saved_current
    @offset = saved_offset
    @modified = saved_modified
  end
  
  def show_documentation
    doc = <<~DOC
    
    #{"HYPERLIST DOCUMENTATION".b}
    #{"Version 2.6 - Complete Specification".fg("245")}
    
    #{"Official HyperList Page:".fg("14")} #{"https://isene.org/hyperlist/".fg("5")}
    #{"By Geir Isene".fg("245")}
    
    #{"═" * 60}
    
    #{"OVERVIEW".b}
    
    HyperList represents a way to describe anything - any state or any
    transition. It represents data in tree-structure lists with a very
    rich set of features. It can be used for any structuring of data:
    
    • Todo lists and project plans
    • Data structures and business processes  
    • Logic breakdowns and outlines of ideas
    • Food recipes, instructions, and much more
    
    Everything. Concise and precise.
    
    #{"═" * 60}
    
    #{"HYPERLIST ITEM STRUCTURE".b}
    
    A HyperList Item consists of these parts in sequence:
    
    1. #{"Starter".fg("5")} (optional)
       • Identifier: Numbers (1.1.1) or mixed (1A1A)
       • Multi-line indicator: + (plus sign)
    
    2. #{"Type".fg("5")} (optional)
       • State: S: or |
       • Transition: T: or /
    
    3. #{"Content".fg("5")} (required)
       • Element: Operator, Qualifier, Property, or Description
       • Additive: Reference, Tag, Comment, Quote, Change Markup
    
    4. #{"Separator".fg("5")}
       • Newline (for new items)
       • Semicolon (for same-line items)
    
    #{"═" * 60}
    
    #{"BASIC STRUCTURE".b}
    
    • Items are organized hierarchically using TAB indentation
    • Each level of indentation represents a deeper level
    • Children add information to their parents
    • A separator between items reads as "then" or "and"
    
    #{"CHECKBOXES".b}
    
    [_]  Unchecked item (underscore placeholder)
    [ ]  Unchecked item (space placeholder)
    [X]  Completed item  
    [x]  Completed item (lowercase)
    [O]  Item in progress
    [-]  Partially completed item
    
    Use 'v' to toggle checkboxes through states.
    Use 'V' to toggle with automatic timestamp on completion.
    Format: [x] YYYY-MM-DD HH.MM: (timestamp after checkbox)
    
    #{"QUALIFIERS".b}
    
    Qualifiers in square brackets tell how many times, when, or under
    what conditions an item exists or is executed:
    
    [?]              Optional item
    [3]              Do item 3 times
    [1+]             Do item 1 or more times  
    [2..5]           Do item 2 to 5 times
    [<4]             Do item less than 4 times
    [>2]             Do item more than 2 times
    [Condition]      Do item if condition is true
    [?Condition]     Same as above, with explicit "if"
    [3, foo=true]    Do item 3 times while foo=true
    [A. B. C]        Do item in context A, then B, then C
    
    Complex example:
    [2..7, Raining, Temp<5°C] Do item 2-7 times while raining and cold
    
    #{"TIMESTAMPS".b}
    
    ISO-8601 format: YYYY-MM-DD HH.MM.SS (can be shortened)
    
    Absolute timestamps:
    [2025-08-11]           On this date
    [2025-08-11 14.30]     At this date and time
    
    Relative timestamps:
    [+YYYY-MM-DD]          Wait this long before doing item
    [-YYYY-MM-DD]          Wait this long before next item
    [+1 week]              Wait one week
    [<+4 days]             Less than 4 days after previous
    
    Recurring items:
    [2025-05-01+7]         Every 7 days starting from date
    [YYYY-MM-03]           Every 3rd of every month
    [Tue,Fri 12.00]        Noon every Tuesday and Friday
    
    #{"PROPERTIES".b}
    
    Any text followed by colon is a property (displayed in red):
    
    Location: Conference room
    Priority: High
    2025-08-11 14.30: Meeting starts
    State: Active
    
    #{"OPERATORS".b}
    
    ALL CAPS followed by colon (displayed in blue):
    
    AND:        All children must be true/done
    OR:         One of the children must be true/done  
    AND/OR:     One or more children
    NOT:        Negation - don't do the following
    THEN:       Sequence indicator
    IF:         Conditional execution
    WHEN:       Time-based condition
    WHILE:      Duration condition
    UNLESS:     Negative condition
    UNTIL:      End condition
    CONTINUOUS: Items run continuously
    ENCRYPTION: Following items are encrypted
    EXAMPLES:   List of examples follows
    CHOOSE:     Select from options
    
    #{"REFERENCES".b}
    
    Enclosed in angle brackets < > (displayed in magenta):
    
    Hard reference (redirect):
    <Item name>            Jump to referenced item
    <<Item name>>          Jump to item and return after
    
    Soft reference (information):
    See <Other item>       Look for more info at reference
    (<Related>)            Apropos reference in parentheses
    
    Special references:
    <+3>                   3 items down
    <-5>                   5 items up
    SKIP                   End current list level
    END                    End whole list
    
    Path references:
    <Parent/Child/Item>    Navigate down hierarchy
    <https://url.com>      External URL
    <file:/path/to/file>   File reference
    
    #{"TEXT FORMATTING".b}
    
    *bold text*        Bold formatting
    /italic text/      Italic formatting
    _underlined_       Underlined text
    
    Formatting can be combined and nested.
    
    #{"ADDITIVES".b}
    
    #{"Comments".fg("6")} (in parentheses):
    (This is a comment)        Not executed in transitions
    
    #{"Separators".fg("2")} (semicolon):
    Item 1; Item 2; Item 3     Multiple items on same line
    
    #{"Quotes".fg("14")} (in quotation marks):
    "Literal text"             Not interpreted as HyperList
    
    #{"Tags".fg("184")} (hashtags):
    #TODO #important           Markers for categorization
    #ProjectAlpha              No spaces allowed in tags
    
    #{"SUBSTITUTIONS".b}
    
    Use curly brackets for variable substitution:
    
    [fruit = apples, oranges] Eat {fruit}
    → Eat apples, then oranges
    
    Ask user for input; Use {input}
    → Variable from user interaction
    
    #{"MULTI-LINE ITEMS".b}
    
    Use + prefix for items spanning multiple lines:
    
    + This is a long item that continues
     on the next line with a space prefix
    
    If one item at a level is multi-line, all items at that
    level must start with + or an identifier.
    
    #{"SEPARATORS".b}
    
    Newline → "then" (for sequence) or "and" (for children)
    Semicolon → Compact multiple items on one line
    
    Examples:
    Task A
      Subtask 1
      Subtask 2
    → Task A consists of Subtask 1 and Subtask 2
    
    Task A; Task B; Task C
    → Task A then Task B then Task C
    
    #{"CHANGE MARKUP".b}
    
    Special tags for document editing:
    
    ##<              Mark item for deletion
    ##>              Mark item to be moved
    ##<-             Indent item left
    ##->             Indent item right  
    ##Text##         Mark item as changed
    
    #{"LITERAL BLOCKS".b}
    
    Escape HyperList interpretation with backslash blocks:
    
    \\
    Everything here is literal text
    [This] is not a <qualifier> or reference
    Until the closing backslash
    \\
    
    #{"EXAMPLES".b}
    
    #{"Simple Todo List:".fg("1")}
    [ ] Buy groceries
      [ ] Milk
      [ ] Bread
    [X] Call dentist
    [O] Write report
    
    #{"Process with Conditions:".fg("1")}
    Morning routine
      Check weather
        [Raining] Get umbrella
        [Cold] Wear jacket
      Make coffee
      [Weekday] Leave by 8am
    
    #{"Project with References:".fg("1")}
    Project Setup
      Define requirements <specs.doc>
      Create timeline
        [2 weeks] Development phase
        [1 week] Testing <Testing/Plan>
      Deploy to production
    
    #{"Complex Logic:".fg("1")}
    System check
      IF: Error detected
        Log error
        NOT: Continue processing
        Send alert
      ELSE:
        Continue normal operation
    
    #{"═" * 60}
    
    #{"COMPLETE HYPERLIST DEFINITION (from specification v2.6)".b}
    
    HyperList
      [1+] HyperList Item
        [?] Starter; OR:
          Identifier (Numbers: Format = "1.1.1.1", Mixed: Format = "1A1A")
            [? Multi-line Item] The Identifier acts like the plus sign ("+")
          Multi-line Indicator = "+"
            + If one Item on a certain indent is multi-line, all Items on the same indent
             (including single-line Items) must start with a plus sign ("+") or <Identifier>
             and all lines on the same indent after the first line must start with a space
        [?] Type
          OR:
            State = "S:" or "|"
            Transition = "T:" or "/"
          Children inherit Type from parent unless marked with different Type
          Can be skipped when the Item is obviously a state or transition
        Content; AND/OR:
          Element; AND/OR:
            Operator
              Anything operating on an Item or a set of Items
                [? Set of Items] Items are indented below the Operator
              Can be any of the usual logical operators
              Is written in capitals ending in a colon and a space
                EXAMPLES: "AND: ", "OR: ", "AND/OR: ", "NOT: ", "IMPLIES: "
              Can contain a Comment to specify the Operator
                EXAMPLE: "OR(PRIORITY): "
                  Sub-Items are to be chosen in the order of priority as listed
              To make the Item run continuously, use "CONTINUOUS: "
                Item is done concurrent with remaining Items
                The Operator can be combined with a timestamp Tag
                  EXAMPLE: "CONTINUOUS: YYYY-MM-07:" = Do the Item weekly
              To show that an Item is encrypted or is to be encrypted, use "ENCRYPTION: "
                OR:
                  The encrypted block can be correctly indented
                  The encrypted block contains indentation and is left justified
                    This would seem to break the list, but is allowed
              A block can be included of "literal text" negating any HyperList markup
                Use a HyperList Item containing only the Operator "\\" to mark start/end
                  EXAMPLE:
                    \\
                    This is a block of literal text...
                    Where nothing counts as HyperList markup
                    Thus - neither this: [?] nor THIS: <Test> - are seen as markup
                    ...until we end this block with...
                    \\
            Qualifier
              Any statement in square brackets that qualifies an Item
              Specifies under what conditions an Item is to be executed, exists or is valid
              Several Qualifiers can be strung together, separated by commas
                All Qualifiers need to be fulfilled for the Item to be valid
                EXAMPLE: "[+YYYY-MM-DD 02.30, Button color = Red, 4, ?] Push button"
              Successive Qualifiers can be strung together, separated by periods; EXAMPLE:
                "[Apples. Oranges. Grapes]"
                  Do Item in the context of "apples", then "oranges", then "grapes"
              EXAMPLES:
                Do Item 3 times = "[3]"
                Do Item if "the mail has arrived" = "[The mail has arrived]"
                Do Item 2 times while "foo=true" = "[2, foo=true]"
                Do Item from 3 to 5 times while "bar=false" = "[3..5, bar=false]"
                Do Item 1 or more times = "[1+]"
                Do Item 1 or more times while "Bob is polite" = "[1+, Bob is polite]"
                Do Item up to 4 times only while "zoo=0" = "[<4, zoo=0]"
              Optional Item = "[?]"
              Timestamp Qualifier = "[YYYY-MM-DD hh.mm.ss]"
                Shorten the format to the appropriate granularity
              Time relations
                Length of time to wait before doing the Item = "[+YYYY-MM-DD]"
                Less than a certain length of time after previous Item = "[<+YYYY-MM-DD]"
                More than a certain length of time after previous Item = "[>+YYYY-MM-DD]"
                Length of time to wait before doing next Item = "[-YYYY-MM-DD]"
                Less than a certain length of time before next Item = "[<-YYYY-MM-DD]"
                More than a certain length of time before next Item = "[>-YYYY-MM-DD]"
                Length of time to wait after doing referenced Item = "[+YYYY-MM-DD<Item>]"
                Other obvious time indicators may be used; EXAMPLES:
                  "[+1 week]"
                  "[-2 Martian years]"
                EXAMPLES:
                  Wait one month before doing the Item = "[+YYYY-01-DD]"
                  Do Item less than 4 days before next Item = "[<-YYYY-MM-04]"
                  Wait one year and two days after Item X = "[+0001-00-02<X>]"
                Time repetition
                  Obvious/intuitive repetition
                    EXAMPLES:
                      "[YYYY-MM-03]" = The third of every month
                      "[YYYY-12-DD]" = Every day in every December
                      "[2011-MM-05]" = The fifth of every month of 2011
                      "[Tue,Fri 12.00]" = Noon every Tuesday and Friday
                  Strict convention
                    Format = YYYY-MM-DD+X Day hh.mm+Y - YYYY-MM-DD hh.mm; EXAMPLES:
                      "[2011-05-01+7 13.00]" = 2011-05-01 1pm, repeated every 7 days
                      "[2011-05-01+2,3,2]" = Every 2, then 3, then 2 days, in repetition
                      "[2011-05-01+2 - 2012-05-01]" = Every second day for one year
                      "[2011-05-01 13.00+1]" = 2011-05-01 1pm, repeated every hour
                      "[2011-05-01 Fri,Sat - 2011-10-01]" = Every Fri & Sat in time interval
                Checking off Items
                  Unchecked Item = "[_]"
                  Item in progress = "[O]"
                  Checked Item = "[x]"
                    [?] Timestamp Tag after ("[x] YYYY-MM-DD hh.mm:ss:")
            Substitution
              Any statement in curly brackets is a substitution; EXAMPLES:
                "[fruit = apples, oranges, bananas] Eat {fruit}"
                  Eat apples, then oranges, then bananas
                "Ask which painting she likes the best; Buy {painting}"
            Property
              Any attribute to the <Content>, ending in a colon and a space
                Gives additional information or description to the Item
              EXAMPLES:
                "Location = Someplace:", "Color = Green:", "Strength = Medium:" and "In Norway:"
            Description
              The main body of the HyperList Item, the "meat" of the line
          Additive; AND/OR:
            Reference
              + An Item name or Identifier, list name or anything else
               enclosed in angle brackets ("<>"); EXAMPLES:
                Reference to a website = "<http://www.isene.org/>"
                Reference to a file = "<file:/path/to/filename>"
              + There are two types of References; OR:
                Redirection (hard Reference)
                  An Item consisting only of a Reference is a redirection
                    For a transition Item = Jump to referenced Item and execute
                      + If the redirect is to jump back after executing
                       the referenced Item (and its children), then add another
                       set of angle brackets (<<Referenced Item>>)
                        + EXAMPLE: Use this when creating subroutines at
                         the end of the list
                    For a state Item = Include the referenced Item
                  An Item consisting only of the key word "SKIP"
                    Ends the current HyperList level
                  An Item consisting only of the key word "END"
                    Ends the whole HyperList
                Soft Reference
                  Reference is part of an Item
                    Look at referenced Item for info only
                  Even softer Reference = have the Reference in parentheses
                    An Item that is only something apropos
              + A Reference to any Item upward in the HyperList is simply a
               Reference to the Item's <Content>
              + A Reference containing several levels down a HyperList needs a "/"
               to separate each level, like a "path" (as with a URL) to the Item
              + To make a Reference to a different branch in a HyperList,
               start the Reference from the highest common level on the list
               and include all Items down to the referenced Item
                EXAMPLE: Reference from here to <Hyperlist Item/Starter/Identifier>
              + For long Items in a Reference, concatenation can be used
                The concatenation must be unique
                  EXAMPLE: Reference from here to <Additive/Comment/Anything...>
            Tag
              A hash sign followed by any letters or numbers, used as a marker (#Tagged)
              Is not executed as a HyperList command
            Comment
              Anything within parentheses is a Comment
              Is not executed as a HyperList command
            Quote
              Anything in quotation marks is a Quote
              Is not executed as a HyperList command
            Change Markup; OR:
              Deletion
                Remove the Item by adding "##<" at the end of the Item
              Motion; OPTIONS:
                Move the Item by adding "##><Reference>"
                  This moves the Item just below the referenced Item
                Move the Item one level in by adding "##<-" at the end of the Item
                Move the Item one level out by adding "##->" at the end of the Item
                  EXAMPLE: Move an Item as a child to referenced Item = "##><Reference>##->"
              Changed Item
                Prefix an Item with "##Text##" to signify that a change has been made
                  Add information inside the angle brackets as appropriate
                    EXAMPLE: To show who changed it and when = "##John 2012-03-21##"
        Separator
          OR:
            Semicolon
              A semicolon is used to separate two HyperList Items on the same line
            Newline
              Used to add another Item on the same level
              Indent
                A Tab or an asterisk ("*")
                Used to add a child
                  A child adds information to its parent
                  A child is another regular <HyperList Item>
          Definition
            A Separator and the same or less indent normally reads "then:"
            [? Parent contains <Description>]
              The Separator and right indent reads "with:" or "consists of:"
            [? NOT: parent contains <Description>]
              The Separator and right indent reads "applies to:"
              A Separator between the children reads "and:"
    
    #{"═" * 60}
    
    HyperList is self-describing and Turing complete.
    It can represent literally anything.
    
    For more information and examples:
    #{"https://isene.org/hyperlist/".fg("5")}
    
    #{"═" * 60}
    
    Press 'q' to return to your list, PgUp/PgDn to scroll
    DOC
    
    # Store current state
    saved_items = @items.dup
    saved_current = @current
    saved_offset = @offset
    saved_filename = @filename
    saved_modified = @modified
    
    # Create temporary documentation items
    @items = doc.split("\n").map { |line| {"text" => line, "level" => 0, "fold" => false, "raw" => true} }
    @current = 0
    @offset = 0
    @modified = false
    
    # Documentation viewer loop
    loop do
      render_main
      @footer.text = "HyperList Documentation | q: return | PgUp/PgDn: scroll"
      @footer.refresh
      
      c = getchr
      case c
      when "q", "ESC"
        break
      when "?"
        # Allow ?? to exit documentation
        if getchr == "?"
          break
        end
      when "j", "DOWN"
        move_down
      when "k", "UP"
        move_up
      when "PgUP"
        page_up
      when "PgDOWN"
        page_down
      when "HOME"
        @current = 0
        @offset = 0
      when "END"
        visible = get_visible_items
        @current = [visible.length - 1, 0].max
      when "g"
        if getchr == "g"
          @current = 0
          @offset = 0
        end
      when "G"
        visible = get_visible_items
        @current = [visible.length - 1, 0].max
      end
    end
    
    # Restore original state
    @items = saved_items
    @current = saved_current
    @offset = saved_offset
    @filename = saved_filename
    @modified = saved_modified
  end
  
  def handle_command
    @mode = :command
    # Set command history (reversed for proper UP arrow navigation)
    @footer.history = @command_history.reverse
    @footer.record = true
    @command = @footer.ask(":", "")
    @mode = :normal
    @footer.clear  # Clear footer immediately
    @footer.refresh
    
    return unless @command
    
    # Add to history if not empty and not duplicate of last entry
    if !@command.empty? && (@command_history.empty? || @command_history.last != @command)
      @command_history << @command
      # Keep only last 100 commands
      @command_history = @command_history.last(100)
      save_command_history
    end
    
    case @command
    when "w", "write"
      if @filename
        save_file
      else
        filename_input = @footer.ask("Save as: ", "")
        @filename = File.expand_path(filename_input) if filename_input && !filename_input.empty?
        save_file if @filename && !@filename.empty?
      end
    when "q", "quit"
      if @modified
        @message = "Unsaved changes! Use :q! or Q to force quit"
      else
        quit
      end
    when "q!"
      quit
    when "wq", "x"
      if @filename
        save_file
      else
        filename_input = @footer.ask("Save as: ", "")
        @filename = File.expand_path(filename_input) if filename_input && !filename_input.empty?
        save_file if @filename && !@filename.empty?
      end
      quit
    when /^w\s+(.+)/
      @filename = File.expand_path($1)
      save_file
    when /^e\s+(.+)/
      if @modified
        @message = "Unsaved changes! Use :e! to force"
      else
        @filename = File.expand_path($1)
        load_file(@filename)
        @current = 0
        @offset = 0
      end
    when /^e!\s+(.+)/
      @filename = File.expand_path($1)
      load_file(@filename)
      @current = 0
      @offset = 0
      @modified = false
    when /^(export|ex)\s+(md|markdown|html|txt|text)\s*(.*)$/
      format = $2
      export_file = $3.empty? ? nil : $3
      export_to(format, export_file)
    when /^(export|ex)$/
      @message = "Usage: :export [md|html|txt] [filename] (or :ex)"
    when "recent", "r"
      show_recent_files
    when "autosave on", "as on"
      @auto_save_enabled = true
      @message = "Auto-save enabled (every #{@auto_save_interval} seconds)"
    when "autosave off", "as off"
      @auto_save_enabled = false
      @message = "Auto-save disabled"
    when /^(autosave|as) (\d+)$/
      @auto_save_interval = $2.to_i
      @message = "Auto-save interval set to #{@auto_save_interval} seconds"
    when "autosave", "as"
      status = @auto_save_enabled ? "enabled" : "disabled"
      @message = "Auto-save is #{status} (interval: #{@auto_save_interval}s)"
    when "t", "template", "templates"
      show_templates
    when "save-template", "savetemplate", "st"
      save_as_template
    when /^save-template\s+(.+)/, /^savetemplate\s+(.+)/, /^st\s+(.+)/
      save_as_template($1.strip)
    when "delete-template", "deletetemplate", "dt"
      delete_template
    when /^delete-template\s+(.+)/, /^deletetemplate\s+(.+)/, /^dt\s+(.+)/
      delete_template($1.strip)
    when "list-templates", "listtemplates", "lt"
      show_template_manager(:list)
    when "foldlevel"
      level = @footer.ask("Fold to level (0-9): ", "")
      if level =~ /^[0-9]$/
        expand_to_level(level.to_i)
        @message = "Folded to level #{level}"
      end
    when "performance", "perf"
      show_performance_stats
    when "graph", "hypergraph", "g"
      export_to_graph
    when "vsplit", "vs"
      toggle_split_view
    when "split"
      # Copy current section to split view
      copy_section_to_split
    when /^set\s+(\w+)=(.+)$/
      # Handle :set option=value
      option = $1
      value = $2.strip
      set_config_option(option, value)
    when /^set\s+(\w+)$/
      # Handle :set option (show current value)
      option = $1
      show_config_option(option)
    when "set"
      # Show all current settings
      show_all_config_options
    else
      @message = "Unknown command: #{@command}"
    end
  end
  
  def set_config_option(option, value)
    # Convert value to appropriate type
    case option
    when "theme"
      if ["light", "normal", "dark"].include?(value)
        @theme = value
        @message = "Theme set to: #{value}"
      else
        @message = "Invalid theme. Use: light, normal, or dark"
      end
    when "wrap"
      @wrap = value == "yes" || value == "true"
      @message = "Line wrapping #{@wrap ? 'enabled' : 'disabled'}"
    when "show_numbers"
      @show_numbers = value == "yes" || value == "true"
      @message = "Line numbers #{@show_numbers ? 'enabled' : 'disabled'}"
    when "fold_level"
      level = value.to_i
      if level >= 0 && level <= 99
        @fold_level = level
        apply_fold_level(level)
        @message = "Fold level set to: #{level}"
      else
        @message = "Invalid fold level. Use 0-99"
      end
    when "auto_save"
      @auto_save_enabled = value == "yes" || value == "true"
      @message = "Auto-save #{@auto_save_enabled ? 'enabled' : 'disabled'}"
    when "auto_save_interval"
      interval = value.to_i
      if interval > 0
        @auto_save_interval = interval
        @message = "Auto-save interval set to: #{interval} seconds"
      else
        @message = "Invalid interval. Must be > 0"
      end
    when "tab_width", "indent_size"
      width = value.to_i
      if width >= 2 && width <= 8
        @indent_size = width
        @message = "Tab width set to: #{width}"
      else
        @message = "Invalid tab width. Use 2-8"
      end
    else
      @message = "Unknown option: #{option}"
    end
    
    # Update config line if it exists
    update_config_line
  end
  
  def show_config_option(option)
    case option
    when "theme"
      @message = "theme=#{@theme}"
    when "wrap"
      @message = "wrap=#{@wrap ? 'yes' : 'no'}"
    when "show_numbers"
      @message = "show_numbers=#{@show_numbers ? 'yes' : 'no'}"
    when "fold_level"
      @message = "fold_level=#{@fold_level}"
    when "auto_save"
      @message = "auto_save=#{@auto_save_enabled ? 'yes' : 'no'}"
    when "auto_save_interval"
      @message = "auto_save_interval=#{@auto_save_interval}"
    when "tab_width", "indent_size"
      @message = "tab_width=#{@indent_size}"
    else
      @message = "Unknown option: #{option}"
    end
  end
  
  def show_all_config_options
    options = []
    options << "theme=#{@theme}"
    options << "wrap=#{@wrap ? 'yes' : 'no'}"
    options << "show_numbers=#{@show_numbers ? 'yes' : 'no'}"
    options << "fold_level=#{@fold_level}"
    options << "auto_save=#{@auto_save_enabled ? 'yes' : 'no'}"
    options << "auto_save_interval=#{@auto_save_interval}"
    options << "tab_width=#{@indent_size}"
    @message = "Settings: #{options.join(', ')}"
  end
  
  def update_config_line
    # Build new config line based on current settings
    # This should preserve the config line and update it with current values
    options = []
    
    # Include fold_level if it's not the default
    if @fold_level != 99
      options << "fold_level=#{@fold_level}"
    end
    
    options << "theme=#{@theme}" if @theme != "normal"
    options << "wrap=yes" if @wrap
    options << "show_numbers=yes" if @show_numbers
    options << "auto_save=yes" if @auto_save_enabled
    options << "auto_save_interval=#{@auto_save_interval}" if @auto_save_interval != 60
    options << "tab_width=#{@indent_size}" if @indent_size != 2
    
    if options.any?
      @config_line = "((#{options.join(', ')}))"
    else
      @config_line = nil
    end
    
    @modified = true
  end
  
  def jump_to_reference
    visible = get_visible_items
    return if @current >= visible.length
    
    text = visible[@current]["text"]
    
    # Look for references in the format <reference> or <<reference>>
    if text =~ /<{1,2}([^>]+)>{1,2}/
      reference = $1
      
      # Check if it's a URL or file reference
      if reference =~ /^(https?:\/\/|file:)/
        open_external_reference(reference)
        return
      end
      
      # Search for the referenced item in the list
      target_index = find_item_by_reference(reference)
      
      if target_index
        @current = target_index
        @message = "Jumped to: #{reference}"
      else
        @message = "Reference not found: #{reference}"
      end
    else
      @message = "No reference found on this line"
    end
  end
  
  def open_file_reference
    visible = get_visible_items
    return if @current >= visible.length
    
    text = visible[@current]["text"]
    
    # Look for file references
    if text =~ /<file:([^>]+)>/
      filepath = $1
      open_external_file(filepath)
    elsif text =~ /<([^>]+\.[^>]+)>/  # Anything with an extension
      filepath = $1
      if File.exist?(filepath)
        open_external_file(filepath)
      else
        @message = "File not found: #{filepath}"
      end
    else
      @message = "No file reference found on this line"
    end
  end
  
  def find_item_by_reference(reference)
    # Handle path-style references (e.g., "Item/SubItem/Detail")
    parts = reference.split('/')
    
    visible = get_visible_items
    
    # First try exact match
    visible.each_with_index do |item, idx|
      if item["text"].include?(reference) || 
         item["text"].gsub(/\[[^\]]*\]/, '').strip.include?(reference)
        return idx
      end
    end
    
    # Try matching by path components
    if parts.length > 1
      current_level = 0
      found_indices = []
      
      parts.each do |part|
        found = false
        visible.each_with_index do |item, idx|
          next if found_indices.include?(idx)
          
          clean_text = item["text"].gsub(/\[[^\]]*\]/, '').strip
          if clean_text.include?(part) && item["level"] >= current_level
            found_indices << idx
            current_level = item["level"]
            found = true
            break
          end
        end
        
        return nil unless found
      end
      
      return found_indices.last
    end
    
    # Try partial match
    visible.each_with_index do |item, idx|
      clean_text = item["text"].gsub(/\[[^\]]*\]/, '').strip
      if clean_text.downcase.include?(reference.downcase)
        return idx
      end
    end
    
    nil
  end
  
  def open_external_reference(url)
    # Try to open URL in default browser
    if RUBY_PLATFORM =~ /darwin/
      system("open", url)
    elsif RUBY_PLATFORM =~ /linux/
      system("xdg-open", url)
    else
      @message = "Cannot open URL on this platform"
    end
  end
  
  def open_external_file(filepath)
    # Expand path if needed
    filepath = File.expand_path(filepath)
    
    if File.exist?(filepath)
      if filepath.end_with?('.hl')
        # Open HyperList file in this app
        if @modified
          @message = "Save current file first"
        else
          @filename = File.expand_path(filepath)
          load_file(@filename)
          @current = 0
          @offset = 0
          @modified = false
        end
      else
        # Open in default application
        if RUBY_PLATFORM =~ /darwin/
          system("open", filepath)
        elsif RUBY_PLATFORM =~ /linux/
          system("xdg-open", filepath)
        else
          @message = "Cannot open file on this platform"
        end
      end
    else
      @message = "File not found: #{filepath}"
    end
  end

  # Encryption methods
  def prompt_password(prompt = "Password: ")
    @footer.text = prompt
    @footer.refresh
    
    # Force terminal to flush output - needed when launched from urxvt
    STDOUT.flush
    
    # When launched through urxvt, force a complete redraw
    if ENV['TERM'] =~ /rxvt/
      sleep 0.1
      # Force complete screen refresh
      Rcurses.clear_screen
      setup_ui
      @footer.text = prompt
      @footer.refresh
      STDOUT.flush
    end
    
    password = ""
    loop do
      begin
        c = getchr
        
        case c
        when "ENTER", "\r", "\n"
          break
        when "BACKSPACE", "BACK", "C-h", "\x7F", "\b"
          password.chop! unless password.empty?
        when "ESC", "C-c"
          return nil
        when nil
          # Skip nil input
          next
        else
          if c && c.length == 1 && c.ord >= 32 && c.ord <= 126
            password += c
          end
        end
        @footer.text = prompt + "*" * password.length
        @footer.refresh
      rescue => e
        # If there's an error, return nil
        @message = "Password input error: #{e.message}"
        return nil
      end
    end
    
    # Clear the password prompt
    @footer.text = ""
    @footer.refresh
    
    # Flush any remaining input to avoid accidental quit
    begin
      while IO.select([$stdin], nil, nil, 0)
        $stdin.read_nonblock(1024)
      end
    rescue IO::WaitReadable, EOFError
      # No more input to flush
    end
    
    password
  end

  def derive_key(password, salt = nil)
    salt ||= OpenSSL::Random.random_bytes(16)
    iterations = 10000
    key_len = 32  # 256-bit key
    key = OpenSSL::PKCS5.pbkdf2_hmac(password, salt, iterations, key_len, OpenSSL::Digest::SHA256.new)
    [key, salt]
  end

  def encrypt_string(text, password = nil)
    if password.nil? && @encryption_key.nil?
      # First time encrypting - ask for password twice
      password = prompt_password("Enter encryption password: ")
      return nil unless password
      
      confirm = prompt_password("Confirm encryption password: ")
      return nil unless confirm
      
      if password != confirm
        @message = "Passwords do not match - encryption cancelled"
        return nil
      end
      
      @encryption_key = password
    else
      password ||= @encryption_key || prompt_password("Enter encryption password: ")
      return nil unless password
    end
    
    # Store key for session if not already stored
    @encryption_key ||= password
    
    cipher = OpenSSL::Cipher.new('AES-256-CBC')
    cipher.encrypt
    
    salt = OpenSSL::Random.random_bytes(16)
    key, _ = derive_key(password, salt)
    cipher.key = key
    
    iv = cipher.random_iv
    encrypted = cipher.update(text) + cipher.final
    
    # Combine salt, iv, and encrypted data, then base64 encode
    combined = salt + iv + encrypted
    "ENC:" + Base64.strict_encode64(combined)
  end

  def decrypt_string(encrypted_text, password = nil)
    return encrypted_text unless encrypted_text.start_with?("ENC:")
    
    password ||= @encryption_key || prompt_password("Enter decryption password: ")
    return nil unless password
    
    # Store key for session if not already stored
    @encryption_key ||= password
    
    begin
      data = Base64.strict_decode64(encrypted_text[4..-1])
      
      salt = data[0..15]
      iv = data[16..31]
      encrypted = data[32..-1]
      
      cipher = OpenSSL::Cipher.new('AES-256-CBC')
      cipher.decrypt
      
      key, _ = derive_key(password, salt)
      cipher.key = key
      cipher.iv = iv
      
      decrypted = cipher.update(encrypted) + cipher.final
      # Force UTF-8 encoding on decrypted content
      decrypted.force_encoding('UTF-8')
      decrypted
    rescue => e
      @message = "Decryption failed. Wrong password?"
      nil
    end
  end

  def is_encrypted_file?(filename)
    # Check if it's a dot file or has .enc extension
    basename = File.basename(filename)
    return true if basename.start_with?(".")
    return true if filename.end_with?(".enc")
    
    # Check first line of file for encryption marker
    begin
      first_line = File.open(filename, &:readline).strip
      first_line.start_with?("ENC:")
    rescue
      false
    end
  end

  def encrypt_file(content, password = nil)
    if password.nil? && @encryption_key.nil?
      # First time encrypting - ask for password twice
      password = prompt_password("Enter encryption password: ")
      return nil unless password
      
      confirm = prompt_password("Confirm encryption password: ")
      return nil unless confirm
      
      if password != confirm
        @message = "Passwords do not match - encryption cancelled"
        return nil
      end
      
      @encryption_key = password
    else
      password ||= @encryption_key || prompt_password("Enter file encryption password: ")
      return nil unless password
    end
    
    encrypt_string(content, password)
  end

  def decrypt_file(encrypted_content, password = nil)
    password ||= @encryption_key || prompt_password("Enter file decryption password: ")
    return nil unless password
    
    # Store the key for the session so line encryption can use it
    @encryption_key = password
    
    decrypt_string(encrypted_content, password)
  end

  def toggle_line_encryption
    return if @items.empty?
    
    begin
      item = @items[@current]
      current_text = item["text"]
      
      if current_text.start_with?("ENC:")
        # Decrypt the line
        decrypted = decrypt_string(current_text)
        if decrypted
          save_undo_state
          item["text"] = decrypted
          @encrypted_lines.delete(@current)
          @modified = true
          @message = "Line decrypted"
        else
          @message = "Decryption failed or cancelled"
        end
      else
        # Encrypt the line
        # Use the existing encryption key if available (from file decryption)
        encrypted = encrypt_string(current_text, @encryption_key)
        if encrypted
          save_undo_state
          item["text"] = encrypted
          @encrypted_lines[@current] = true
          @modified = true
          @message = "Line encrypted (🔒 indicator shown)"
          # Clear the processed cache to force re-rendering
          @processed_cache = {}
        else
          @message = "Encryption cancelled"
        end
      end
    rescue => e
      @message = "Encryption error: #{e.message}"
    end
  end
  
  def detect_indentation(lines)
    # Try to auto-detect indentation size from the file
    # Find the greatest common divisor of all indentation levels
    indents = []
    
    lines.each do |line|
      next if line.strip.empty?
      
      # Skip tab-indented lines for space detection
      next if line.start_with?("\t")
      
      # Count leading spaces
      spaces = line[/^ */].length
      indents << spaces if spaces > 0
    end
    
    return if indents.empty?
    
    # Find the GCD of all indentation levels
    gcd = indents.reduce(indents.first) { |g, n| n.gcd(g) }
    
    # Clamp to reasonable range (2-5)
    if gcd >= 2 && gcd <= 5
      @indent_size = gcd
    elsif gcd > 5
      # If GCD is too large, try to find a divisor between 2-5
      [5, 4, 3, 2].each do |size|
        if gcd % size == 0
          @indent_size = size
          break
        end
      end
    end
    # If we can't detect, keep the current setting
  end
  
  def load_config
    # Don't load config, let each file's indentation be detected
    # Config is only saved when user explicitly changes with 'I'
  end
  
  def save_config
    require 'yaml'
    config_dir = File.dirname(@config_file)
    FileUtils.mkdir_p(config_dir) unless Dir.exist?(config_dir)
    
    config = {
      'indent_size' => @indent_size
    }
    
    File.write(@config_file, config.to_yaml)
  rescue => e
    @message = "Failed to save config: #{e.message}"
  end
  
  def cycle_indent_size
    @indent_size = (@indent_size % 5) + 1  # Cycles through 1,2,3,4,5
    @indent_size = 2 if @indent_size < 2  # Ensure minimum of 2
    save_config
    @message = "Indentation set to #{@indent_size} spaces"
    @modified = true  # Mark as modified since display will change
  end
  
  def ensure_templates_dir
    FileUtils.mkdir_p(@templates_dir) unless File.exist?(@templates_dir)
  end

  def load_templates
    # Start with built-in templates
    templates = {
      "project" => [
        {"text" => "Project: =Project Name=", "level" => 0},
        {"text" => "[_] Define project scope", "level" => 1},
        {"text" => "[_] Identify stakeholders", "level" => 1},
        {"text" => "[_] Create timeline", "level" => 1},
        {"text" => "Planning", "level" => 1},
        {"text" => "[_] Resource allocation", "level" => 2},
        {"text" => "[_] Risk assessment", "level" => 2},
        {"text" => "[_] Budget planning", "level" => 2},
        {"text" => "Implementation", "level" => 1},
        {"text" => "[_] Phase 1: Foundation", "level" => 2},
        {"text" => "[_] Phase 2: Development", "level" => 2},
        {"text" => "[_] Phase 3: Testing", "level" => 2},
        {"text" => "[_] Phase 4: Deployment", "level" => 2},
        {"text" => "Review", "level" => 1},
        {"text" => "[_] Gather feedback", "level" => 2},
        {"text" => "[_] Document lessons learned", "level" => 2},
        {"text" => "[_] Archive project materials", "level" => 2}
      ],
      "meeting" => [
        {"text" => "Meeting: =Title=", "level" => 0},
        {"text" => "Date: #{Time.now.strftime('%Y-%m-%d %H:%M')}", "level" => 1},
        {"text" => "Location: =Conference Room/Online=", "level" => 1},
        {"text" => "Attendees", "level" => 1},
        {"text" => "=Name 1=", "level" => 2},
        {"text" => "=Name 2=", "level" => 2},
        {"text" => "Agenda", "level" => 1},
        {"text" => "[_] Opening remarks", "level" => 2},
        {"text" => "[_] Review previous action items", "level" => 2},
        {"text" => "[_] Main topics", "level" => 2},
        {"text" => "Topic 1: =Description=", "level" => 3},
        {"text" => "Topic 2: =Description=", "level" => 3},
        {"text" => "[_] Q&A session", "level" => 2},
        {"text" => "[_] Next steps", "level" => 2},
        {"text" => "Action Items", "level" => 1},
        {"text" => "[_] =Action 1= - Assigned to: =Name= - Due: =Date=", "level" => 2},
        {"text" => "[_] =Action 2= - Assigned to: =Name= - Due: =Date=", "level" => 2},
        {"text" => "Notes", "level" => 1},
        {"text" => "=Add meeting notes here=", "level" => 2}
      ],
      "daily" => [
        {"text" => "Daily Plan: #{Time.now.strftime('%Y-%m-%d')}", "level" => 0},
        {"text" => "Morning Routine", "level" => 1},
        {"text" => "[_] Review calendar", "level" => 2},
        {"text" => "[_] Check emails", "level" => 2},
        {"text" => "[_] Plan priorities", "level" => 2},
        {"text" => "Priority Tasks", "level" => 1},
        {"text" => "[_] =High Priority Task 1=", "level" => 2},
        {"text" => "[_] =High Priority Task 2=", "level" => 2},
        {"text" => "[_] =High Priority Task 3=", "level" => 2},
        {"text" => "Regular Tasks", "level" => 1},
        {"text" => "[_] =Task 1=", "level" => 2},
        {"text" => "[_] =Task 2=", "level" => 2},
        {"text" => "Meetings/Appointments", "level" => 1},
        {"text" => "=Time= - =Meeting/Event=", "level" => 2},
        {"text" => "Notes", "level" => 1},
        {"text" => "=Daily observations and reflections=", "level" => 2}
      ],
      "checklist" => [
        {"text" => "Checklist: =Title=", "level" => 0},
        {"text" => "[_] Item 1", "level" => 1},
        {"text" => "[_] Item 2", "level" => 1},
        {"text" => "[_] Item 3", "level" => 1},
        {"text" => "[_] Item 4", "level" => 1},
        {"text" => "[_] Item 5", "level" => 1}
      ],
      "brainstorm" => [
        {"text" => "Brainstorming: =Topic=", "level" => 0},
        {"text" => "Problem Statement", "level" => 1},
        {"text" => "=Define the problem or opportunity=", "level" => 2},
        {"text" => "Ideas", "level" => 1},
        {"text" => "Category 1", "level" => 2},
        {"text" => "Idea A", "level" => 3},
        {"text" => "Idea B", "level" => 3},
        {"text" => "Category 2", "level" => 2},
        {"text" => "Idea C", "level" => 3},
        {"text" => "Idea D", "level" => 3},
        {"text" => "Evaluation Criteria", "level" => 1},
        {"text" => "Feasibility", "level" => 2},
        {"text" => "Impact", "level" => 2},
        {"text" => "Resources Required", "level" => 2},
        {"text" => "Next Steps", "level" => 1},
        {"text" => "[_] Research top ideas", "level" => 2},
        {"text" => "[_] Create action plan", "level" => 2}
      ],
      "recipe" => [
        {"text" => "Recipe: =Name=", "level" => 0},
        {"text" => "Servings: =Number=", "level" => 1},
        {"text" => "Prep Time: =Time=", "level" => 1},
        {"text" => "Cook Time: =Time=", "level" => 1},
        {"text" => "Ingredients", "level" => 1},
        {"text" => "=Amount= =Ingredient 1=", "level" => 2},
        {"text" => "=Amount= =Ingredient 2=", "level" => 2},
        {"text" => "=Amount= =Ingredient 3=", "level" => 2},
        {"text" => "Instructions", "level" => 1},
        {"text" => "[_] Step 1: =Description=", "level" => 2},
        {"text" => "[_] Step 2: =Description=", "level" => 2},
        {"text" => "[_] Step 3: =Description=", "level" => 2},
        {"text" => "Notes", "level" => 1},
        {"text" => "=Tips, variations, serving suggestions=", "level" => 2}
      ]
    }
    
    # Load user templates from templates directory
    if File.directory?(@templates_dir)
      Dir.glob(File.join(@templates_dir, "*.hlt")).each do |template_file|
        template_name = File.basename(template_file, ".hlt")
        begin
          template_data = JSON.parse(File.read(template_file))
          # Convert template data to the expected format
          if template_data.is_a?(Hash) && template_data["items"]
            templates[template_name] = template_data["items"].map do |item|
              {"text" => item["text"], "level" => item["level"]}
            end
          end
        rescue => e
          # Skip invalid template files
        end
      end
    end
    
    templates
  end
  
  def save_as_template(name = nil)
    # Ask for template name if not provided
    if name.nil? || name.empty?
      name = @footer.ask("Template name: ", "")
      return if name.nil? || name.empty?
    end
    
    # Sanitize template name
    name = name.gsub(/[^a-zA-Z0-9_-]/, '_')
    
    # Ask for description
    description = @footer.ask("Template description (optional): ", "")
    
    # Prepare template data
    template_data = {
      "name" => name,
      "description" => description,
      "created" => Time.now.strftime("%Y-%m-%dT%H:%M:%S"),
      "items" => @items.map do |item|
        {
          "text" => item["text"],
          "level" => item["level"]
        }
      end
    }
    
    # Save template file
    template_path = File.join(@templates_dir, "#{name}.hlt")
    
    # Check if template already exists
    if File.exist?(template_path)
      response = @footer.ask("Template '#{name}' already exists. Overwrite? (y/n): ", "")
      return unless response.downcase == 'y'
    end
    
    File.write(template_path, JSON.pretty_generate(template_data))
    @message = "Template '#{name}' saved successfully"
  end
  
  def delete_template(name = nil)
    # Get list of user templates
    user_templates = get_user_templates
    
    if user_templates.empty?
      @message = "No user templates found"
      return
    end
    
    # Show template list if name not provided
    if name.nil? || name.empty?
      show_template_manager(:delete)
      return
    end
    
    template_path = File.join(@templates_dir, "#{name}.hlt")
    
    if File.exist?(template_path)
      response = @footer.ask("Delete template '#{name}'? (y/n): ", "")
      if response.downcase == 'y'
        File.delete(template_path)
        @message = "Template '#{name}' deleted"
        # Reload templates
        @templates = load_templates
      end
    else
      @message = "Template '#{name}' not found"
    end
  end
  
  def get_user_templates
    templates = []
    if File.directory?(@templates_dir)
      Dir.glob(File.join(@templates_dir, "*.hlt")).each do |template_file|
        template_name = File.basename(template_file, ".hlt")
        begin
          template_data = JSON.parse(File.read(template_file))
          templates << {
            "name" => template_name,
            "description" => template_data["description"] || "",
            "created" => template_data["created"] || "",
            "path" => template_file
          }
        rescue => e
          # Skip invalid template files
        end
      end
    end
    templates.sort_by { |t| t["name"] }
  end
  
  def show_template_manager(action = :list)
    # Store original state
    original_state = {
      items: @items.dup,
      current: @current,
      offset: @offset,
      filename: @filename,
      modified: @modified
    }
    
    user_templates = get_user_templates
    
    # Build template manager view
    @items = []
    case action
    when :delete
      @items << {"text" => "DELETE TEMPLATE (press Enter to delete, q to cancel)", "level" => 0, "fold" => false, "raw" => true}
    else
      @items << {"text" => "USER TEMPLATES (press Enter to select, q to cancel)", "level" => 0, "fold" => false, "raw" => true}
    end
    @items << {"text" => "="*50, "level" => 0, "fold" => false, "raw" => true}
    
    if user_templates.empty?
      @items << {"text" => "No user templates found", "level" => 0, "fold" => false, "raw" => true}
    else
      user_templates.each_with_index do |template, idx|
        desc = template["description"].empty? ? "No description" : template["description"]
        created = template["created"].empty? ? "" : " (#{Time.parse(template["created"]).strftime('%Y-%m-%d')})"
        @items << {
          "text" => "#{idx+1}. #{template["name"]}: #{desc}#{created}",
          "level" => 0,
          "fold" => false,
          "raw" => true,
          "template_name" => template["name"],
          "template_action" => action
        }
      end
    end
    
    @current = 2  # Start at first template
    @offset = 0
    
    selected_template = nil
    exit_loop = false
    
    # Template manager loop
    while !exit_loop
      begin
        render_main
        footer_text = case action
        when :delete
          "Delete Template | Enter: delete | q: cancel | j/k: navigate"
        else
          "User Templates | Enter: select | q: cancel | j/k: navigate"
        end
        @footer.text = footer_text
        @footer.refresh
        
        c = getchr
        next if c.nil?
        
        case c
        when "q", "ESC", "C-c", "Q"
          exit_loop = true
        when "j", "DOWN"
          @current = [@current + 1, @items.length - 1].min
        when "k", "UP"
          @current = [@current - 1, 2].max
        when "ENTER", "RETURN", "\n", "\r"
          if @current >= 2 && @current < @items.length
            item = @items[@current]
            if item && item.is_a?(Hash) && item["template_name"]
              selected_template = item["template_name"]
              exit_loop = true
            end
          end
        end
      rescue => e
        @message = "Error in template manager: #{e.message}"
        exit_loop = true
      end
    end
    
    # Restore original state
    @items = original_state[:items]
    @current = original_state[:current]
    @offset = original_state[:offset]
    @filename = original_state[:filename]
    @modified = original_state[:modified]
    
    # Process selected template
    if selected_template && action == :delete
      delete_template(selected_template)
    end
    
    selected_template
  end
  
  def show_templates
    # Store original state in an array to ensure proper restoration
    original_state = {
      items: @items.dup,
      current: @current,
      offset: @offset, 
      filename: @filename,
      modified: @modified
    }
    
    # Create template selection view combining built-in and user templates
    template_list = [
      ["project", "Project Plan - Complete project management template", "built-in"],
      ["meeting", "Meeting Agenda - Structure for meeting notes", "built-in"],
      ["daily", "Daily Planner - Daily task and schedule template", "built-in"],
      ["checklist", "Simple Checklist - Basic checkbox list", "built-in"],
      ["brainstorm", "Brainstorming Session - Idea generation template", "built-in"],
      ["recipe", "Recipe - Cooking recipe structure", "built-in"]
    ]
    
    # Add user templates to the list
    user_templates = get_user_templates
    user_templates.each do |template|
      desc = template["description"].empty? ? "User template" : template["description"]
      template_list << [template["name"], desc, "user"]
    end
    
    # Build template selection items
    @items = []
    @items << {"text" => "TEMPLATES (press Enter to insert, q to cancel)", "level" => 0, "fold" => false, "raw" => true}
    @items << {"text" => "="*50, "level" => 0, "fold" => false, "raw" => true}
    
    # Add built-in templates section
    @items << {"text" => "BUILT-IN TEMPLATES:", "level" => 0, "fold" => false, "raw" => true}
    template_list.select { |t| t[2] == "built-in" }.each_with_index do |(key, desc, type), idx|
      @items << {
        "text" => "  #{idx+1}. #{key.capitalize}: #{desc}", 
        "level" => 0, 
        "fold" => false, 
        "raw" => true, 
        "template_key" => key
      }
    end
    
    # Add user templates section if any exist
    if user_templates.any?
      @items << {"text" => "", "level" => 0, "fold" => false, "raw" => true}
      @items << {"text" => "USER TEMPLATES:", "level" => 0, "fold" => false, "raw" => true}
      template_list.select { |t| t[2] == "user" }.each_with_index do |(key, desc, type), idx|
        @items << {
          "text" => "  #{key}: #{desc}", 
          "level" => 0, 
          "fold" => false, 
          "raw" => true, 
          "template_key" => key
        }
      end
    end
    
    @current = 2  # Start at first template
    @offset = 0
    
    selected_template = nil
    exit_loop = false
    
    # Template selection loop
    while !exit_loop
      begin
        render_main
        @footer.text = "Templates | Enter: insert | q: cancel | j/k: navigate"
        @footer.refresh
        
        c = getchr
        
        # Skip truly nil input
        next if c.nil?
        
        case c
        when "q", "ESC", "C-c", "Q"
          exit_loop = true
        when "j", "DOWN"
          @current = [@current + 1, @items.length - 1].min
        when "k", "UP"
          @current = [@current - 1, 2].max
        when "ENTER", "RETURN", "\n", "\r", "l"
          if @current >= 2 && @current < @items.length
            item = @items[@current]
            if item && item.is_a?(Hash) && item["template_key"]
              selected_template = item["template_key"]
              exit_loop = true
            end
          end
        when /^[1-6]$/
          idx = c.to_i - 1
          if idx >= 0 && idx < template_list.length
            selected_template = template_list[idx][0]
            exit_loop = true
          end
        end
        
      rescue => e
        # Log error but continue
        @message = "Error in template loop: #{e.message}"
        exit_loop = true
      end
    end
    
    # Restore original state
    @items = original_state[:items]
    @current = original_state[:current]
    @offset = original_state[:offset]
    @filename = original_state[:filename]
    @modified = original_state[:modified]
    
    # Flush any remaining input to avoid accidental actions
    begin
      while IO.select([$stdin], nil, nil, 0)
        $stdin.read_nonblock(1024)
      end
    rescue IO::WaitReadable, EOFError
      # No more input to flush
    end
    
    # Insert template if one was selected
    if selected_template && !selected_template.empty?
      begin
        template_items = @templates[selected_template]
        if template_items && template_items.is_a?(Array) && !template_items.empty?
          insert_template(selected_template)
        else
          @message = "Template '#{selected_template}' not found or empty"
        end
      rescue => e
        @message = "Error inserting template: #{e.message}"
      end
    end
  end
  
  def insert_template(template_key)
    template_items = @templates[template_key]
    return unless template_items
    
    # Ensure we have valid items and current position
    return if @items.nil? || @items.empty?
    return if @current.nil? || @current < 0 || @current >= @items.length
    return unless @items[@current]
    
    save_undo_state
    
    # Get current item level to adjust template indentation
    current_level = @items[@current]["level"] || 0
    
    # Insert template items after current position
    insertion_point = @current + 1
    
    template_items.each_with_index do |template_item, idx|
      new_item = {
        "text" => template_item["text"],
        "level" => current_level + template_item["level"],
        "fold" => false
      }
      @items.insert(insertion_point + idx, new_item)
    end
    
    @modified = true
    @message = "Template '#{template_key}' inserted"
  end
  
  def start_macro_recording(key)
    @macro_recording = true
    @macro_key = key
    @macro_buffer = []
    @message = "Recording macro to register '#{key}'..."
  end
  
  def stop_macro_recording
    if @macro_key && !@macro_buffer.empty?
      # Remove the 'q' that stopped recording from the buffer if it's there
      @macro_buffer.pop if @macro_buffer.last == "q"
      @macro_register[@macro_key] = @macro_buffer.dup
      @message = "Macro recorded to register '#{@macro_key}' (#{@macro_buffer.length} actions)"
    else
      @message = "Macro recording cancelled"
    end
    @macro_recording = false
    @macro_key = nil
    @macro_buffer = []
  end
  
  def play_macro(key)
    macro = @macro_register[key]
    if macro && !macro.empty?
      @message = "Playing macro '#{key}'..."
      render_footer
      
      # Replay each action in the macro
      macro.each do |action|
        # Simulate the key press
        case @mode
        when :normal
          process_normal_key(action)
        when :insert
          # Handle insert mode separately if needed
          @mode = :normal if action == "ESC"
        end
        
        # Update display after each action for visual feedback
        render
      end
      
      @message = "Macro '#{key}' executed (#{macro.length} actions)"
    else
      @message = "No macro in register '#{key}'"
    end
  end
  
  def process_normal_key(c)
    # This processes a single key in normal mode for macro replay
    case c
    when "j", "DOWN"
      move_down
    when "k", "UP"
      move_up
    when "h"
      go_to_parent
    when "l"
      go_to_first_child
    when "o"
      insert_line_below
    when "O"
      insert_line_above
    when "a"
      insert_child
    when "A"
      insert_outdented
    when "d"
      # Check if it's dd
      if getchr == "d"
        delete_line
      end
    when "y"
      # Check if it's yy
      if getchr == "y"
        copy_line
      end
    when "p"
      paste
    when "v"
      toggle_checkbox
    when "V"
      toggle_checkbox_with_date
    when "TAB"
      # Indent with move conditions (moved from RIGHT key)
      should_move_children = should_move_with_children?
      if @split_view && @active_pane == :split
        indent_split_right(should_move_children)
      else
        indent_right(should_move_children)
      end
    when "S-TAB"
      # Unindent with move conditions (moved from LEFT key)
      should_move_children = should_move_with_children?
      if @split_view && @active_pane == :split
        indent_split_left(should_move_children)
      else
        indent_left(should_move_children)
      end
    when "RIGHT"
      # Uncollapse item if it is collapsed
      uncollapse_item
    when "LEFT"
      # Collapse item if it has children
      collapse_item
    when " "
      toggle_fold
    when "u"
      undo
    when "/"
      # Skip search in macros for now
      @message = "Search skipped in macro"
    when "i", "ENTER"
      # Skip interactive editing in macros
      @message = "Text editing skipped in macro"
    end
  end
  
  def toggle_split_view
    @split_view = !@split_view
    if @split_view
      # Use the actual items array for full document split view
      # This ensures changes in either pane affect both views
      @split_items = @items
      @split_current = @current
      @split_offset = @offset
      @active_pane = :main
      set_message("Split view enabled. Use Ctrl-w w to switch panes.")
    else
      @split_items = []
      set_message("Split view disabled")
    end
    
    # Clear cached content to force re-render
    @last_rendered_content = ""
    @processed_cache.clear
    
    # Recreate UI
    setup_ui
    
    # Force complete re-render
    render_main
    render_split_pane if @split_view
    render_footer
  end
  
  def copy_section_to_split
    if !@split_view
      toggle_split_view
    end
    
    # Find the current section (same or less indented level)
    current_item = @items[@current]
    current_level = current_item["level"]
    
    # Find section boundaries
    start_idx = @current
    end_idx = @current
    
    # Find start of section (go up to same or less level)
    (0...@current).reverse_each do |idx|
      if @items[idx]["level"] <= current_level
        start_idx = idx
        break
      end
    end
    
    # Find end of section
    (@current + 1...@items.length).each do |idx|
      if @items[idx]["level"] <= current_level
        break
      end
      end_idx = idx
    end
    
    # Copy section to split view - use references, not copies
    # The slice creates a new array but contains references to the same item objects
    @split_items = @items[start_idx..end_idx]
    @split_current = 0
    @split_offset = 0
    
    @message = "Section copied to split view (#{@split_items.length} items)"
  end
  
  def handle_window_command
    c = getchr
    case c
    when "w"
      # Switch active pane
      if @split_view
        @active_pane = (@active_pane == :main) ? :split : :main
        @message = "Switched to #{@active_pane} pane"
        # Force re-render both panes to update highlighting
        render_main
        render_split_pane
        render_footer
      end
    when "v"
      # Vertical split
      toggle_split_view
    when "o"
      # Close split, keep only current pane
      @split_view = false
      setup_ui
      @message = "Split view closed"
    when "="
      # Make panes equal size (already equal in our implementation)
      @message = "Panes are equal size"
    end
  end
  
  def get_visible_split_items
    return [] unless @split_items
    
    visible = []
    skip_until_level = nil
    
    @split_items.each do |item|
      # Skip items that are folded
      if skip_until_level
        if item["level"] > skip_until_level
          next
        else
          skip_until_level = nil
        end
      end
      
      visible << item
      
      # Check if this item is folded and has children
      if item["fold"] && has_children_in_array?(visible.length - 1, @split_items)
        skip_until_level = item["level"]
      end
    end
    
    visible
  end
  
  def render_split_pane
    return unless @split_view && @split_pane
    
    # Get visible items respecting fold state
    visible_items = get_visible_split_items
    
    # Build ALL lines for the pane (like we do for main pane)
    lines = []
    
    # Track which line number each item starts at (for scroll calculation)
    item_line_starts = {}
    
    visible_items.each_with_index do |item, idx|
      next unless item
      
      # Record where this item starts in the display
      item_line_starts[idx] = lines.length
      
      # Find the item's position in the original split_items array
      real_idx = @split_items.index(item)
      
      # Handle multi-line items (split by embedded newlines)
      embedded_lines = item["text"].split("\n")
      text_lines = []
      
      embedded_lines.each do |embedded_line|
        if @wrap
          # Wrap each embedded line separately
          wrapped = wrap_line(embedded_line, @split_pane.w - 10, item["level"])
          text_lines.concat(wrapped)
        else
          text_lines << embedded_line
        end
      end
      
      text_lines.each_with_index do |text_line, line_idx|
        # Add line number if enabled (only on first line)
        line = ""
        if @show_numbers
          if line_idx == 0
            actual_line_number = real_idx ? real_idx + 1 : 0  # +1 for 1-based line numbers
            line = "#{actual_line_number.to_s.rjust(4)} "
          else
            line = "     "  # Empty space for continuation lines
          end
        end
        
        line += "    " * item["level"]
        
        # Add fold indicator with colors (only on first line)
        if line_idx == 0
          if real_idx && has_children_in_array?(real_idx, @split_items)
            if item["fold"]
              line += "▶".fg("245") + " "
            else
              line += "▷".fg("245") + " "
            end
          else
            line += "  "
          end
        else
          line += "  "  # Just spacing for continuation lines
        end
        
        # Apply process_text for syntax highlighting
        processed = process_text(text_line, false)
        line += processed
        
        # Apply background highlighting for current item in split pane (all lines)
        if idx == @split_current
          # Choose background color based on whether this is the active pane
          bg_color = @active_pane == :split ? "237" : "234"
          bg_code = "\e[48;5;#{bg_color}m"
          reset_bg = "\e[49m"
          line = bg_code + line.gsub(/\e\[49m/, '') + reset_bg
        end
        
        lines << line
      end
    end
    
    # Add a blank line at the bottom to show end of document
    lines << ""
    
    # Set the full content to the pane and let rcurses handle scrolling
    @split_pane.text = lines.join("\n")
    
    # Calculate how many extra lines are created by wrapping
    extra_wrapped_lines = 0
    lines[0..-2].each do |line|  # Exclude the blank line we added
      # Remove ANSI codes for length calculation
      clean_line = line.gsub(/\e\[[0-9;]*m/, '')
      if clean_line.length > @split_pane.w
        # This line will wrap - calculate how many extra lines it creates
        extra_lines = (clean_line.length.to_f / @split_pane.w).ceil - 1
        extra_wrapped_lines += extra_lines
      end
    end
    
    # Calculate scroll position based on actual line positions, not item indices
    scrolloff = 3
    total_lines = lines.length  # Total number of actual display lines
    page = @split_pane.h  # Height of the display area
    
    # Get the actual line where the current item starts
    current_line = item_line_starts[@split_current] || 0
    
    if total_lines <= page
      # If everything fits, always start from the very top
      @split_pane.ix = 0
    elsif current_line - @split_pane.ix < scrolloff
      # If we're too close to the top of the pane, scroll up
      @split_pane.ix = [current_line - scrolloff, 0].max
    elsif (@split_pane.ix + page - 1 - current_line) < scrolloff
      # If we're too close to the bottom of the pane, scroll down
      # Make sure we don't scroll past the last line
      max_scroll = [total_lines - page, 0].max
      @split_pane.ix = [current_line + scrolloff - page + 1, max_scroll].min
    end
    
    @split_pane.refresh
  end
  
  def has_children_in_array?(idx, items_array)
    return false if idx >= items_array.length - 1
    current_level = items_array[idx]["level"]
    next_level = items_array[idx + 1]["level"]
    next_level > current_level
  end
  
  def move_in_active_pane(direction)
    if @split_view && @active_pane == :split
      visible = get_visible_split_items
      case direction
      when :down
        if @split_current >= visible.length - 1
          # Wrap to top
          @split_current = 0
        else
          @split_current = @split_current + 1
        end
      when :up
        if @split_current <= 0
          # Wrap to bottom
          @split_current = visible.length - 1
        else
          @split_current = @split_current - 1
        end
      end
    else
      case direction
      when :down
        move_down
      when :up
        move_up
      end
    end
  end
  
  def show_performance_stats
    total_items = @items.length
    visible_items = get_visible_items.length
    folded_count = @items.count { |item| item["fold"] }
    cache_size = @processed_cache.size
    split_info = @split_view ? " | Split: #{@split_items.length} items" : ""
    
    @message = "Items: #{total_items} (#{visible_items} visible, #{folded_count} folded) | Cache: #{cache_size}#{split_info}"
  end
  
  def export_to_graph
    # Ask user for graph options - return nil if cancelled (ESC pressed)
    graph_type = @footer.ask("Graph type (state/trans) - ESC to cancel: ", "")
    return if graph_type.empty?
    return unless graph_type =~ /^(state|trans)$/
    
    direction = @footer.ask("Direction (TB/BT/LR/RL) - ESC to cancel: ", "")
    return if direction.empty?
    return unless direction =~ /^(TB|BT|LR|RL)$/
    
    line_style = @footer.ask("Line style (spline/ortho/poly) - ESC to cancel: ", "")
    return if line_style.empty?
    return unless line_style =~ /^(spline|ortho|polyline)$/
    line_style = "polyline" if line_style == "poly"
    
    theme = @footer.ask("Theme (default/business/tech/pastel) - ESC to cancel: ", "")
    return if theme.empty?
    return unless theme =~ /^(default|business|tech|pastel)$/
    
    # Generate default output filename based on current file
    default_output = if @filename
      File.basename(@filename, File.extname(@filename)) + ".png"
    else
      "hyperlist_graph.png"
    end
    
    output_file = @footer.ask("Output filename (.png) - ESC to cancel: ", default_output)
    return if output_file == default_output && output_file.empty?  # If default was empty and user pressed ESC
    return if !output_file || output_file.strip.empty?
    output_file += ".png" unless output_file.end_with?(".png")
    
    open_after = @footer.ask("Open graph after generation? (y/n) - ESC to cancel: ", "")
    return if open_after.empty?
    open_after = open_after.downcase == "y"
    
    # Generate the graph
    begin
      dot_content = generate_dot_graph(graph_type, direction, line_style, theme)
      
      # Write DOT file temporarily
      dot_file = output_file.sub(/\.png$/, '.dot')
      File.write(dot_file, dot_content)
      
      # Generate PNG using Graphviz
      system("dot -Tpng #{dot_file} -o #{output_file}")
      
      # Clean up DOT file
      File.delete(dot_file) if File.exist?(dot_file)
      
      if File.exist?(output_file)
        @message = "Graph exported to #{output_file}"
        
        # Open the graph if requested
        if open_after
          # Try different methods to open the file
          if system("which xdg-open > /dev/null 2>&1")
            system("xdg-open #{output_file} 2>/dev/null &")
            @message += " (opened)"
          elsif system("which runmailcap > /dev/null 2>&1")
            system("runmailcap #{output_file} 2>/dev/null &")
            @message += " (opened)"
          elsif system("which open > /dev/null 2>&1")  # macOS
            system("open #{output_file} 2>/dev/null &")
            @message += " (opened)"
          else
            @message += " (could not auto-open)"
          end
        end
      else
        @message = "Failed to generate graph. Is Graphviz installed?"
      end
    rescue => e
      @message = "Graph export failed: #{e.message}"
    end
  end
  
  def generate_dot_graph(type, direction, spline, theme)
    # Theme definitions
    themes = {
      'default' => {
        node_color: 'black',
        edge_color: 'black',
        font: 'Helvetica',
        bgcolor: 'white'
      },
      'business' => {
        node_color: '#2c3e50',
        edge_color: '#34495e',
        font: 'Arial',
        bgcolor: '#ecf0f1',
        node_style: 'rounded,filled',
        node_fillcolor: '#3498db',
        node_fontcolor: 'white'
      },
      'tech' => {
        node_color: '#00ff00',
        edge_color: '#00aa00',
        font: 'Courier',
        bgcolor: 'black',
        node_fontcolor: '#00ff00'
      },
      'pastel' => {
        node_color: '#8b7d6b',
        edge_color: '#cdaa7d',
        font: 'Georgia',
        bgcolor: '#fff8dc',
        node_style: 'filled',
        node_fillcolor: '#ffe4b5'
      }
    }
    
    current_theme = themes[theme] || themes['default']
    
    dot = "digraph HyperGraph {\n"
    dot << "rankdir=#{direction}\n"
    dot << "splines=#{spline}\n"
    dot << "bgcolor=\"#{current_theme[:bgcolor]}\"\n" if current_theme[:bgcolor]
    dot << "overlap=false\n"
    
    # Edge settings
    dot << "edge [fontsize=8 len=1"
    dot << " color=\"#{current_theme[:edge_color]}\"" if current_theme[:edge_color]
    dot << "]\n"
    
    # Node settings
    dot << "node ["
    dot << "shape=#{type == 'trans' ? 'box' : 'ellipse'}"
    dot << " color=\"#{current_theme[:node_color]}\"" if current_theme[:node_color]
    dot << " fontname=\"#{current_theme[:font]}\"" if current_theme[:font]
    dot << " fontcolor=\"#{current_theme[:node_fontcolor]}\"" if current_theme[:node_fontcolor]
    dot << " style=\"#{current_theme[:node_style]}\"" if current_theme[:node_style]
    dot << " fillcolor=\"#{current_theme[:node_fillcolor]}\"" if current_theme[:node_fillcolor]
    dot << "]\n\n"
    
    # Process HyperList items into nodes
    @items.each_with_index do |item, idx|
      next if item["raw"]  # Skip raw items like help text
      
      node_id = "node_#{idx}"
      label = escape_dot_label(item["text"])
      
      # Check for special item types and set attributes
      attributes = []
      attributes << "label=\"#{label}\""
      
      # Handle operators (AND:, OR:, etc.)
      if item["text"] =~ /^\s*([A-Z][A-Z_\-() \/]*):(.*)$/
        operator = $1
        if ["AND", "OR", "NOT", "IMPLIES", "CONTINUOUS"].include?(operator)
          attributes << "shape=doubleoctagon"
          attributes << "width=0.2 height=0.2"
        end
      end
      
      # Handle qualifiers (items with [])
      if item["text"] =~ /\[([^\]]+)\]/
        qualifier = $1
        case qualifier
        when "?"
          attributes << "shape=diamond"  # Optional items as diamonds
        when "_"
          label = "☐ #{label}"
          attributes[0] = "label=\"#{label}\""
        when "x"
          label = "☑ #{label}"
          attributes[0] = "label=\"#{label}\""
        when "O"
          label = "⊙ #{label}"
          attributes[0] = "label=\"#{label}\""
        else
          # Check for conditions
          if qualifier =~ /^[^,]+$/
            attributes << "shape=diamond"
            attributes << "tooltip=\"Condition: #{qualifier}\""
          end
        end
      end
      
      # Handle properties (Color:, Location:, etc.)
      if item["text"] =~ /^\s*([A-Z][a-z]+.*?):\s+(.+)$/
        property = $1
        value = $2
        if property.downcase == "color" && value =~ /(\w+)/
          color_val = $1.downcase
          # Map common color names if needed
          color_map = {
            'red' => 'red', 'green' => 'green', 'blue' => 'blue',
            'yellow' => 'yellow', 'orange' => 'orange', 'purple' => 'purple'
          }
          if color_map[color_val]
            attributes << "color=\"#{color_map[color_val]}\""
            attributes << "style=filled"
            attributes << "fillcolor=\"#{color_map[color_val]}20\""  # Light fill
          end
        end
      end
      
      # Handle tags
      if item["text"] =~ /#(\w+)/
        tags = item["text"].scan(/#(\w+)/).flatten
        attributes << "tooltip=\"Tags: #{tags.join(', ')}\""
      end
      
      # Add node to graph
      dot << "\"#{node_id}\" [#{attributes.join(', ')}]\n"
    end
    
    dot << "\n"
    
    # Add edges based on type
    if type == 'state'
      # State graph: hierarchical connections
      @items.each_with_index do |item, idx|
        next if item["raw"]
        
        # Find children
        children = find_graph_children(idx)
        children.each do |child_idx|
          from_node = "node_#{idx}"
          to_node = "node_#{child_idx}"
          
          edge_attrs = []
          
          # Style based on operator
          if item["text"] =~ /^\s*OR:/
            edge_attrs << "style=\"dashed\""
          elsif item["text"] =~ /^\s*AND:/
            edge_attrs << "color=\"black:black\""
          end
          
          dot << "\"#{from_node}\" -> \"#{to_node}\""
          dot << " [#{edge_attrs.join(', ')}]" if edge_attrs.any?
          dot << "\n"
        end
        
        # Handle references (<item>)
        if item["text"] =~ /<([^>]+)>/
          ref = $1
          target_idx = find_reference_target(ref)
          if target_idx
            dot << "\"node_#{idx}\" -> \"node_#{target_idx}\" [style=\"dotted\"]\n"
          end
        end
      end
    else
      # Transition graph: sequential flow with special handling
      @items.each_with_index do |item, idx|
        next if item["raw"]
        
        # Special handling for OR/AND operators
        if item["text"] =~ /^\s*(OR|AND):/
          operator = $1
          children = find_graph_children(idx)
          
          if children.any?
            # Connect operator to all its children
            children.each do |child_idx|
              style = operator == "OR" ? "style=\"dashed\"" : "color=\"black:black\""
              dot << "\"node_#{idx}\" -> \"node_#{child_idx}\" [#{style}]\n"
            end
            
            # Find convergence point
            converge_idx = find_next_at_level_or_above(idx, item["level"])
            if converge_idx
              # Connect all children to convergence point
              children.each do |child_idx|
                last_in_branch = find_last_in_branch(child_idx)
                dot << "\"node_#{last_in_branch}\" -> \"node_#{converge_idx}\"\n"
              end
            end
            next
          end
        end
        
        # Normal sequential flow
        next_idx = find_next_graph_item(idx)
        if next_idx
          from_node = "node_#{idx}"
          to_node = "node_#{next_idx}"
          dot << "\"#{from_node}\" -> \"#{to_node}\"\n"
        end
      end
    end
    
    dot << "}\n"
    dot
  end
  
  def escape_dot_label(text)
    # Clean and escape text for DOT labels
    label = text.dup
    
    # Remove ANSI color codes if present
    label.gsub!(/\e\[([0-9;]+)m/, '')
    label.gsub!(/\[38;5;\d+m/, '')
    
    # Remove leading/trailing whitespace and indentation
    label.strip!
    
    # Remove checkboxes at the beginning
    label.gsub!(/^\[([x_O])\]\s*/, '')
    
    # Truncate if too long
    if label.length > 50
      label = label[0..47] + "..."
    end
    
    # Escape special characters for DOT
    label.gsub('\\', '\\\\').gsub('"', '\"').gsub('#', '\#')
  end
  
  def find_graph_children(parent_idx)
    children = []
    parent_level = @items[parent_idx]["level"]
    
    (parent_idx + 1...@items.length).each do |i|
      next if @items[i]["raw"]
      if @items[i]["level"] > parent_level
        children << i if @items[i]["level"] == parent_level + 1
      else
        break
      end
    end
    
    children
  end
  
  def find_reference_target(ref)
    # Find item containing the reference text
    @items.find_index { |item| !item["raw"] && item["text"].include?(ref) }
  end
  
  def find_next_at_level_or_above(start_idx, level)
    (start_idx + 1...@items.length).each do |i|
      next if @items[i]["raw"]
      return i if @items[i]["level"] <= level
    end
    nil
  end
  
  def find_last_in_branch(start_idx)
    current_level = @items[start_idx]["level"]
    last_idx = start_idx
    
    (start_idx + 1...@items.length).each do |i|
      next if @items[i]["raw"]
      if @items[i]["level"] > current_level
        last_idx = i
      else
        break
      end
    end
    
    last_idx
  end
  
  def find_next_graph_item(idx)
    current_level = @items[idx]["level"]
    
    # Find next item at same level or first child
    (idx + 1...@items.length).each do |i|
      next if @items[i]["raw"]
      
      # Return if same level or immediate child
      if @items[i]["level"] == current_level || @items[i]["level"] == current_level + 1
        return i
      elsif @items[i]["level"] < current_level
        # Going back up the hierarchy
        break
      end
    end
    
    nil
  end
  
  def set_message(text)
    @message = text
    @message_timeout = nil  # Reset timeout so message shows immediately
  end
  
  def set_mark(mark)
    @marks ||= {}
    visible = get_visible_items
    if @current < visible.length
      real_idx = get_real_index(visible[@current])
      @marks[mark] = real_idx
      @message = "Mark '#{mark}' set"
    end
  end
  
  def jump_to_mark(mark)
    @marks ||= {}
    if @marks[mark]
      # Save current position for ''
      @previous_position = @current
      
      # Find the marked item in visible items
      target_idx = @marks[mark]
      visible = get_visible_items
      visible_idx = visible.find_index { |item| get_real_index(item) == target_idx }
      
      if visible_idx
        @current = visible_idx
        @message = "Jumped to mark '#{mark}'"
      else
        @message = "Mark '#{mark}' item is not visible (may be folded)"
      end
    else
      @message = "Mark '#{mark}' not set"
    end
  end
  
  def jump_to_previous_position
    if @previous_position
      old_pos = @current
      @current = @previous_position
      @previous_position = old_pos
      @message = "Jumped to previous position"
    else
      @message = "No previous position"
    end
  end
  
  def quit
    save_command_history
    Cursor.show
    Rcurses.clear_screen
    exit
  end
  
  def run
    # Initialize rcurses explicitly (no longer auto-initialized)
    Rcurses.init!
    
    # Flush any buffered input (like the Enter key from running the command)
    while IO.select([$stdin], nil, nil, 0)
      $stdin.read_nonblock(1024) rescue break
    end
    
    # Now that rcurses is initialized, set up the UI properly
    Rcurses.clear_screen
    Cursor.hide
    setup_ui
    
    render
    
    loop do
      # Check for auto-save
      check_auto_save if @auto_save_enabled
      
      c = getchr
      
      # Skip nil input (shouldn't happen normally)
      next if c.nil?
      
      # Skip newline at the very start (buffered from command execution)
      if c == "\n" && @last_key.nil?
        next
      end
      
      # Track last key for double-key combinations
      prev_key = @last_key
      @last_key = c
      
      # Record macro if recording (but not the 'q' that stops recording)
      if @macro_recording && !(c == "q")
        @macro_buffer << c
      end
      
      case @mode
      when :normal
        case c
        when "r"  # Redo
          redo_change
        when "?"
          show_help
        when "j", "DOWN"
          move_in_active_pane(:down)
        when "k", "UP"
          move_in_active_pane(:up)
        when "h"
          go_to_parent
        when "l"
          go_to_first_child
        when "LEFT"
          # Collapse item if it has children
          collapse_item
        when "RIGHT"
          # Uncollapse item if it is collapsed
          uncollapse_item
        when "PgUP"  # Page Up
          page_up
        when "PgDOWN"  # Page Down
          page_down
        when "HOME"   # Home
          if @split_view && @active_pane == :split
            @split_current = 0
          else
            @current = 0
            @offset = 0
            update_presentation_focus if @presentation_mode
          end
        when "END"    # End
          if @split_view && @active_pane == :split
            visible = get_visible_split_items
            @split_current = [visible.length - 1, 0].max
          else
            visible = get_visible_items
            @current = [visible.length - 1, 0].max
            update_presentation_focus if @presentation_mode
          end
        when "g"  # Go to top (gg) or text case commands (gU/gu)
          next_c = getchr
          case next_c
          when "g"  # gg - go to top
            if @split_view && @active_pane == :split
              @split_current = 0
            else
              @current = 0
              @offset = 0
              update_presentation_focus if @presentation_mode
            end
          when "U"  # gU - uppercase line
            uppercase_line
          when "u"  # gu - lowercase line
            lowercase_line
          end
        when "G"  # Go to bottom
          if @split_view && @active_pane == :split
            visible = get_visible_split_items
            @split_current = [visible.length - 1, 0].max
          else
            visible = get_visible_items
            @current = [visible.length - 1, 0].max
            # Let normal offset logic position the last item
            update_presentation_focus if @presentation_mode
          end
        when "R"  # Jump to reference (was gr)
          jump_to_reference
        when "F"  # Open file reference (was gf)
          open_file_reference
        when " "
          toggle_fold
        when "z"
          next_c = getchr
          case next_c
          when "a"
            @items.each { |item| item["fold"] = !item["fold"] }
          when "R"
            @items.each { |item| item["fold"] = false }
          when "M"
            @items.each_with_index do |item, idx|
              item["fold"] = true if has_children?(idx, @items)
            end
          when "o"
            visible = get_visible_items
            if @current < visible.length
              real_idx = get_real_index(visible[@current])
              @items[real_idx]["fold"] = false if real_idx
            end
          when "c"
            visible = get_visible_items
            if @current < visible.length
              real_idx = get_real_index(visible[@current])
              if real_idx && has_children?(real_idx, @items)
                @items[real_idx]["fold"] = true
              end
            end
          end
        when '0'
          # Single 0 pressed, ask for fold level
          level = @footer.ask("Fold to level: ", "")
          if level =~ /^\d+$/
            expand_to_level(level.to_i)
            @message = "Folded to level #{level}"
          end
        when /[1-9]/
          expand_to_level(c.to_i)
        when "C-L"  # Move item and descendants down (C-J is newline)
          move_item_down(true)
        when "i", "ENTER", "\n"  # i or ENTER to edit (C-J sends \n)
          edit_line
        when "o"
          insert_line
        when "O"
          @current -= 1 if @current > 0
          insert_line
          @current += 1
        when "a"
          insert_child
        when "A"
          insert_outdented
        when "W"
          # Save and quit (shortcut for :wq)
          if @filename
            save_file
          else
            filename_input = @footer.ask("Save as: ", "")
            @filename = File.expand_path(filename_input) if filename_input && !filename_input.empty?
            save_file if @filename && !@filename.empty?
          end
          quit if @filename
        when "I"
          # Cycle through indentation sizes (2-5 spaces)
          cycle_indent_size
        when "t"
          show_templates
        when "D"  # Delete line only (without children)
          delete_line(false)  # Delete current line only
        when "C-D"  # Delete line and all descendants explicitly
          delete_line(true)
        when "C-E"  # Toggle line encryption
          toggle_line_encryption
        when "y"  # Yank/copy single line
          yank_line(false)
        when "Y"  # Yank/copy line with all descendants
          yank_line(true)
        when "p"
          paste_line
        when "S-UP"  # Move item up
          move_item_up(false)
        when "S-DOWN"  # Move item down
          move_item_down(false)
        when "C-UP"  # Move up in visible list (with children only if collapsed)
          move_item_up(should_move_with_children?)
        when "C-DOWN"  # Move down in visible list (with children only if collapsed)
          move_item_down(should_move_with_children?)
        when "C-K"  # Alternative: Move up in visible list (for terminals that intercept C-UP)
          move_item_up(should_move_with_children?)
        when "TAB"
          if @presentation_mode
            # In presentation mode, Tab goes to next sibling
            jump_to_next_sibling
          else
            # Normal mode: Indent with move conditions (moved from RIGHT key)
            should_move_children = should_move_with_children?
            if @split_view && @active_pane == :split
              indent_split_right(should_move_children)
            else
              indent_right(should_move_children)
            end
          end
        when "S-TAB"  # Shift-Tab
          if @presentation_mode
            # In presentation mode, Shift-Tab goes to previous sibling
            jump_to_prev_sibling
          else
            # Normal mode: Unindent with move conditions (moved from LEFT key)
            should_move_children = should_move_with_children?
            if @split_view && @active_pane == :split
              indent_split_left(should_move_children)
            else
              indent_left(should_move_children)
            end
          end
        when "u"
          undo
        when "\x12"  # Ctrl-R for redo (0x12 is Ctrl-R ASCII code)
          redo_change
        when "v"
          toggle_checkbox
        when "V"
          toggle_checkbox_with_date
        when "."
          repeat_last_action
        when "/"
          search_forward
        when "n"
          search_next
        when "N"
          jump_to_next_template_marker
        when "P"
          toggle_presentation_mode
        when "\x15"  # Ctrl-U for State/Transition underline toggle
          # Cycle through underline modes: 0 (none) -> 1 (states) -> 2 (transitions) -> 0
          @st_underline_mode = (@st_underline_mode + 1) % 3
          # Clear cache to force re-rendering
          @processed_cache.clear
          case @st_underline_mode
          when 0
            @message = "Underline mode: OFF"
          when 1
            @message = "Underline mode: STATES (S: and |)"
          when 2
            @message = "Underline mode: TRANSITIONS (T: and /)"
          end
        when "\\"
          next_c = getchr
          case next_c
          when "u"
            # Alternative for Ctrl-U (backslash-u)
            @st_underline_mode = (@st_underline_mode + 1) % 3
            @processed_cache.clear
            case @st_underline_mode
            when 0
              @message = "Underline mode: OFF"
            when 1
              @message = "Underline mode: STATES (S: and |)"
            when 2
              @message = "Underline mode: TRANSITIONS (T: and /)"
            end
          end
        when ":"
          handle_command
        when "q"
          # Regular quit
          if @modified
            @message = "Unsaved changes! Use :q! or Q to force quit"
          else
            quit
          end
        when "m"
          # Mark setting
          c2 = getchr
          if c2 && c2 =~ /[a-z]/
            # Set mark
            set_mark(c2)
          end
        when "M"
          # Macro recording
          if @macro_recording
            # Stop recording
            stop_macro_recording
          else
            c2 = getchr
            if c2 && c2 =~ /[a-z]/
              start_macro_recording(c2)
            end
          end
        when "'"
          # Jump to mark
          c2 = getchr
          if c2 == "'"
            # Jump to previous position
            jump_to_previous_position
          elsif c2 && c2 =~ /[a-z]/
            # Jump to mark
            jump_to_mark(c2)
          end
        when "@"
          # Play macro
          next_c = getchr
          play_macro(next_c) if next_c && next_c =~ /[a-z]/
        when "w"
          # Switch active pane if split view is active
          if @split_view
            @active_pane = (@active_pane == :main) ? :split : :main
            @message = "Switched to #{@active_pane} pane"
            # Force re-render both panes to update highlighting
            render_main
            render_split_pane
            render_footer
          else
            @message = "Split view not active. Use :vs to enable"
          end
        when "Q"  # Force quit
          quit
        when "ESC", "C-C"  # ESC or Ctrl-C
          if @search && !@search.empty?
            # Clear search on ESC
            @search = ""
            @search_matches = []
            @message = "Search cleared"
            clear_cache
          end
          # ESC no longer quits the program - only clears search
        end
      end
      
      render
    end
  rescue Interrupt
    quit
  ensure
    Cursor.show
    # Screen clearing disabled for debugging
    # Rcurses.clear_screen
  end
end

# Main
# When installed as a gem executable, this file is loaded (not executed directly)
# so we can't use __FILE__ == $0. Just run unless we already handled help/version.
unless ARGV[0] == '-h' || ARGV[0] == '--help' || ARGV[0] == '-v' || ARGV[0] == '--version'
  app = HyperListApp.new(ARGV[0])
  app.run
end